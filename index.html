
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AbSgram HD — хронология сообщений</title>
    <style>
        /* ========== СТИЛИ ПОЛНОСТЬЮ (БЕЗ ИЗМЕНЕНИЙ) ========== */
        :root {
            --primary: #FF6B35;
            --primary-dark: #E55A2B;
            --primary-light: #FF8E53;
            --dark: #1A1A1A;
            --sidebar: #252525;
            --message-out: #FF6B35;
            --message-in: #333333;
            --text: #F5F5F5;
            --text-secondary: #AAAAAA;
            --success: #4CAF50;
            --error: #F44336;
            --warning: #FF9800;
            --info: #2196F3;
            --group: #FFB347;
            --voice: #9C27B0;
            --call: #00BCD4;
            --video-call: #E91E63;
            --channel: #8BC34A;
            --date-separator: rgba(255,107,53,0.15);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: var(--dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #1A1A1A 0%, #2D1B0E 100%);
        }
        
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .hidden {
            display: none !important;
        }
        
        .header {
            background: var(--sidebar);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid rgba(255,107,53,0.2);
            background: linear-gradient(90deg, #252525 0%, #2A1E16 100%);
        }
        
        .header-title {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
            flex: 1;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,107,53,0.4);
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255,107,53,0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .back-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .back-btn:hover {
            background: rgba(255,107,53,0.1);
            color: var(--primary);
        }
        
        .search-container {
            padding: 15px;
            background: var(--sidebar);
            border-bottom: 1px solid rgba(255,107,53,0.1);
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 14px 20px 14px 45px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,107,53,0.3);
            border-radius: 30px;
            color: var(--text);
            font-size: 16px;
            outline: none;
            transition: all 0.3s;
        }
        
        .search-input:focus {
            border-color: var(--primary);
            background: rgba(255,107,53,0.05);
            box-shadow: 0 0 0 3px rgba(255,107,53,0.1);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
        }
        
        .search-icon {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--primary);
            font-size: 18px;
            z-index: 1;
        }
        
        .users-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: transparent;
        }
        
        .users-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .users-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }
        
        .users-list::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }
        
        .user-item {
            display: flex;
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
            align-items: center;
            transition: all 0.3s;
            border-radius: 15px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
        }
        
        .user-item:hover {
            background: rgba(255,107,53,0.1);
            transform: translateX(5px);
        }
        
        .user-item:active {
            transform: translateX(5px) scale(0.98);
        }
        
        .user-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 22px;
            margin-right: 15px;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            border: 3px solid var(--primary);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .user-info {
            flex: 1;
            min-width: 0;
        }
        
        .user-name {
            font-weight: 700;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 16px;
            color: var(--text);
        }
        
        .user-username {
            color: var(--primary-light);
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }
        
        .user-status {
            font-size: 13px;
            font-weight: 600;
        }
        
        .user-status.online {
            color: var(--success);
        }
        
        .user-status.offline {
            color: var(--text-secondary);
        }
        
        .auth-form {
            background: linear-gradient(135deg, var(--sidebar) 0%, #2A1E16 100%);
            padding: 40px;
            border-radius: 25px;
            width: 90%;
            max-width: 420px;
            margin: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,107,53,0.2);
            position: relative;
            overflow: hidden;
        }
        
        .auth-form::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
        }
        
        .logo {
            text-align: center;
            margin-bottom: 35px;
        }
        
        .logo-icon {
            width: 90px;
            height: 90px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: 800;
            margin: 0 auto 20px;
            color: white;
            box-shadow: 0 10px 30px rgba(255,107,53,0.4);
        }
        
        .logo h2 {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .logo p {
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 300;
        }
        
        .input-group {
            margin-bottom: 25px;
            position: relative;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-group input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            color: var(--text);
            font-size: 16px;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255,107,53,0.05);
            box-shadow: 0 0 0 4px rgba(255,107,53,0.1);
        }
        
        .input-group input::placeholder {
            color: rgba(255,255,255,0.3);
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: 25px;
            color: var(--text-secondary);
            font-size: 15px;
        }
        
        .auth-toggle a {
            color: var(--primary);
            cursor: pointer;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .auth-toggle a:hover {
            text-decoration: underline;
            color: var(--primary-light);
        }
        
        .chats-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: transparent;
        }
        
        .chats-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .chats-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }
        
        .chats-list::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }
        
        .chat-item {
            display: flex;
            padding: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
            align-items: center;
            transition: all 0.3s;
            border-radius: 15px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
            position: relative;
        }
        
        .chat-item:hover {
            background: rgba(255,107,53,0.1);
            transform: translateX(5px);
        }
        
        .chat-item:active {
            transform: translateX(5px) scale(0.98);
        }
        
        .chat-item.active {
            background: rgba(255,107,53,0.15);
            border-left: 4px solid var(--primary);
            box-shadow: 0 5px 15px rgba(255,107,53,0.2);
        }
        
        .chat-item.group-chat {
            border-left: 4px solid var(--group);
        }

        .chat-item.channel {
            border-left: 4px solid var(--channel);
        }
        
        .chat-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 22px;
            margin-right: 15px;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            border: 3px solid var(--primary);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .group-avatar {
            background: var(--group);
            border-color: var(--group);
        }

        .channel-avatar {
            background: var(--channel);
            border-color: var(--channel);
        }
        
        .chat-info {
            flex: 1;
            min-width: 0;
        }
        
        .chat-name {
            font-weight: 700;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 16px;
            color: var(--text);
        }
        
        .chat-last {
            color: var(--text-secondary);
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .chat-time {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .chat-unread-badge {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 6px;
            margin-left: auto;
            margin-right: 10px;
            box-shadow: 0 2px 5px rgba(255,107,53,0.3);
        }
        
        .chat-unread-mention {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
        }
        
        .new-chat-btn {
            position: fixed;
            bottom: 25px;
            right: 25px;
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(255,107,53,0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            color: white;
            z-index: 100;
            font-weight: bold;
        }
        
        .new-chat-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 12px 30px rgba(255,107,53,0.6);
        }
        
        .messages-container {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: linear-gradient(135deg, #1A1A1A 0%, #2D1B0E 100%);
        }
        
        .messages-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .messages-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }
        
        .messages-container::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }
        
        /* Стили разделителя дат (НОВЫЙ) */
        .date-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0 10px 0;
            position: relative;
        }
        .date-separator span {
            background: rgba(255,107,53,0.15);
            color: var(--primary-light);
            padding: 6px 18px;
            border-radius: 30px;
            font-size: 13px;
            font-weight: 600;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,107,53,0.3);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 2;
        }
        .date-separator::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(255,107,53,0.2);
            z-index: 1;
        }
        
        .message {
            max-width: 75%;
            padding: 14px 18px;
            border-radius: 20px;
            word-wrap: break-word;
            position: relative;
            animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            line-height: 1.5;
            transition: opacity 0.3s;
        }
        .message.replying {
            border-left: 4px solid var(--primary);
        }
        .message.search-highlight {
            outline: 3px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 20px var(--primary);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message-out {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--message-out) 0%, var(--primary-dark) 100%);
            border-bottom-right-radius: 5px;
            color: white;
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
        }
        
        .message-in {
            align-self: flex-start;
            background: var(--message-in);
            border-bottom-left-radius: 5px;
            border: 1px solid rgba(255,107,53,0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .message-time {
            font-size: 11px;
            text-align: right;
            margin-top: 8px;
            opacity: 0.8;
            font-weight: 500;
        }
        
        .message-in .message-time {
            color: var(--text-secondary);
        }
        
        .message-out .message-time {
            color: rgba(255,255,255,0.8);
        }
        
        .message-sender {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--primary-light);
        }
        
        .message-status {
            display: inline-block;
            margin-left: 6px;
            font-size: 12px;
        }
        
        .status-sent {
            opacity: 0.6;
        }
        
        .status-read {
            color: #4CAF50;
        }
        
        /* Стили для цитируемого сообщения (ответ) */
        .reply-preview {
            background: rgba(0,0,0,0.2);
            border-left: 4px solid var(--primary);
            padding: 8px 12px;
            border-radius: 10px;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: 300px;
        }
        .reply-sender {
            font-weight: bold;
            color: var(--primary-light);
            font-size: 12px;
        }
        .reply-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .reply-image-icon {
            color: var(--primary);
        }
        .message.replying-to {
            border-left: 4px solid var(--primary);
        }
        .replying-indicator {
            background: var(--sidebar);
            padding: 8px 15px;
            border-top: 1px solid rgba(255,107,53,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: var(--primary-light);
        }
        .replying-indicator .cancel-reply {
            margin-left: auto;
            cursor: pointer;
            color: var(--error);
            font-size: 18px;
            padding: 0 5px;
        }

        .file-message {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-top: 8px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .file-message:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }
        
        .file-icon {
            font-size: 24px;
            margin-right: 10px;
            color: var(--primary);
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-name {
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-size {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .image-message {
            max-width: 100%;
            margin-top: 8px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
            position: relative;
        }
        
        .image-message:hover {
            transform: scale(1.02);
            border-color: var(--primary);
        }
        
        .image-message img {
            width: 100%;
            height: auto;
            display: block;
            max-height: 400px;
            object-fit: contain;
            background: #000;
        }
        
        .video-message {
            max-width: 100%;
            margin-top: 8px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
            position: relative;
            background: #000;
        }
        
        .video-message:hover {
            transform: scale(1.02);
            border-color: var(--primary);
        }
        
        .video-message video {
            width: 100%;
            height: auto;
            display: block;
            max-height: 400px;
            object-fit: contain;
        }
        
        .video-play-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid white;
        }
        
        .video-play-btn:hover {
            background: rgba(255, 107, 53, 0.8);
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        .voice-message {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-top: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .voice-message:hover {
            background: rgba(255,255,255,0.15);
        }
        
        .voice-icon {
            font-size: 24px;
            margin-right: 10px;
            color: var(--voice);
        }
        
        .voice-duration {
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .voice-wave {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, var(--voice) 0%, transparent 100%);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .voice-wave::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: wave 2s infinite linear;
        }
        
        @keyframes wave {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .message-input-container {
            padding: 12px 15px;
            background: var(--sidebar);
            display: flex;
            gap: 8px;
            align-items: center;
            border-top: 1px solid rgba(255,107,53,0.1);
            background: linear-gradient(90deg, #252525 0%, #2A1E16 100%);
        }
        
        .message-input {
            flex: 1;
            padding: 10px 15px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,107,53,0.3);
            border-radius: 20px;
            color: var(--text);
            font-size: 14px;
            resize: none;
            max-height: 80px;
            font-family: inherit;
            font-weight: 500;
            transition: all 0.3s;
            min-height: 40px;
        }
        
        .message-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255,107,53,0.05);
            box-shadow: 0 0 0 3px rgba(255,107,53,0.1);
        }
        
        .send-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(255,107,53,0.3);
        }
        
        .send-btn:hover:not(:disabled) {
            transform: scale(1.1) rotate(10deg);
            box-shadow: 0 4px 15px rgba(255,107,53,0.5);
        }
        
        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .attach-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: var(--text);
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 18px;
        }
        
        .attach-btn:hover {
            background: rgba(255,107,53,0.2);
            color: var(--primary);
        }
        
        .voice-btn {
            width: 40px;
            height: 40px;
            background: rgba(156,39,176,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: var(--voice);
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 18px;
            position: relative;
        }
        
        .voice-btn:hover {
            background: rgba(156,39,176,0.3);
        }
        
        .voice-btn.recording {
            background: var(--error);
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .recording-time {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--error);
            color: white;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .profile-content {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            background: linear-gradient(135deg, #1A1A1A 0%, #2D1B0E 100%);
        }
        
        .profile-header {
            text-align: center;
            margin-bottom: 35px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255,107,53,0.1);
        }
        
        .profile-avatar-container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
            cursor: pointer;
        }
        
        .profile-avatar {
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 52px;
            font-weight: 800;
            border: 4px solid var(--primary);
            background-size: cover;
            background-position: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 15px 35px rgba(255,107,53,0.3);
        }
        
        .profile-avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 20px 40px rgba(255,107,53,0.4);
        }
        
        .avatar-upload {
            position: absolute;
            bottom: 5px;
            right: 5px;
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            border: 3px solid var(--sidebar);
            transition: all 0.3s;
            color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .avatar-upload:hover {
            transform: scale(1.1) rotate(15deg);
            box-shadow: 0 8px 20px rgba(255,107,53,0.4);
        }
        
        .profile-name {
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 8px;
            color: var(--text);
        }
        
        .profile-username {
            color: var(--primary-light);
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .profile-status {
            display: inline-flex;
            align-items: center;
            background: rgba(76,175,80,0.1);
            padding: 6px 15px;
            border-radius: 20px;
            color: var(--success);
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            background: var(--success);
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        .info-section {
            background: linear-gradient(135deg, var(--sidebar) 0%, #2A1E16 100%);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255,107,53,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .info-section h3 {
            color: var(--primary);
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .info-section h3::before {
            content: '';
            display: block;
            width: 4px;
            height: 20px;
            background: var(--primary);
            border-radius: 2px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            align-items: center;
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .info-label {
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 500;
        }
        
        .info-value {
            color: var(--text);
            font-size: 16px;
            font-weight: 600;
            text-align: right;
            max-width: 60%;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            background: linear-gradient(135deg, var(--sidebar) 0%, #2A1E16 100%);
            border-radius: 25px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalFade 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 25px 60px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,107,53,0.2);
            position: relative;
            overflow: hidden;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
        }
        
        @keyframes modalFade {
            from { opacity: 0; transform: scale(0.9) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .modal-title {
            font-size: 22px;
            font-weight: 800;
            margin-bottom: 25px;
            text-align: center;
            color: var(--primary);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 25px;
        }
        
        .avatar-preview {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            margin: 0 auto 25px;
            background-size: cover;
            background-position: center;
            border: 4px solid var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 70px;
            font-weight: 800;
            color: white;
            box-shadow: 0 15px 35px rgba(255,107,53,0.3);
        }
        
        .avatar-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .avatar-option {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 20px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .avatar-option:hover {
            transform: scale(1.15);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        .avatar-option.selected {
            border-color: white;
            box-shadow: 0 0 0 4px var(--primary), 0 10px 25px rgba(255,107,53,0.5);
            transform: scale(1.1);
        }
        
        .avatar-upload-area {
            border: 3px dashed var(--primary);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 25px;
            transition: all 0.3s;
            background: rgba(255,107,53,0.05);
        }
        
        .avatar-upload-area:hover {
            background: rgba(255,107,53,0.1);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }
        
        .notification {
            position: fixed;
            top: 25px;
            right: 25px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 15px;
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1001;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            font-weight: 500;
            border-left: 5px solid var(--primary-light);
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%) translateY(-20px); opacity: 0; }
            to { transform: translateX(0) translateY(0); opacity: 1; }
        }
        
        .notification.error {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
            border-left-color: #FF5252;
        }
        
        .notification.success {
            background: linear-gradient(135deg, var(--success) 0%, #388E3C 100%);
            border-left-color: #81C784;
        }
        
        .notification.info {
            background: linear-gradient(135deg, var(--info) 0%, #1976D2 100%);
            border-left-color: #64B5F6;
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            padding: 40px;
        }
        
        .empty-state .icon {
            font-size: 70px;
            margin-bottom: 25px;
            opacity: 0.5;
        }
        
        .empty-state p {
            font-size: 17px;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #777 0%, #555 100%);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        .loading {
            display: inline-block;
            width: 22px;
            height: 22px;
            border: 3px solid rgba(255,255,255,.2);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .loading-overlay .loading {
            width: 60px;
            height: 60px;
            border-width: 6px;
        }
        
        .search-hint {
            color: var(--text-secondary);
            font-size: 13px;
            text-align: center;
            padding: 10px;
            font-style: italic;
            border-top: 1px solid rgba(255,107,53,0.1);
            background: rgba(255,255,255,0.02);
            border-radius: 0 0 10px 10px;
            margin-top: -5px;
        }
        
        .group-members {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 10px;
        }
        
        .member-tag {
            display: inline-flex;
            align-items: center;
            background: var(--primary);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            margin: 5px;
            font-size: 14px;
        }
        
        .member-tag .remove {
            margin-left: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .create-group-btn {
            margin-top: 20px;
        }
        
        .modal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 15px;
        }
        
        .modal-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .modal-tab.active {
            background: rgba(255,107,53,0.2);
            color: var(--primary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .group-info-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,107,53,0.1);
        }
        
        .group-avatar-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: var(--group);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: 800;
            margin: 0 auto 15px;
            color: white;
            border: 4px solid var(--group);
            box-shadow: 0 10px 25px rgba(255,179,71,0.3);
        }
        
        .group-members-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .group-member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80px;
        }
        
        .group-member-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 18px;
        }
        
        .group-member-name {
            font-size: 12px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .admin-badge {
            background: var(--group);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 5px;
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        
        .slide-up {
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* ЯРКИЕ КНОПКИ ЗВОНКА */
        .call-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00BCD4 0%, #00838F 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 16px;
            box-shadow: 0 3px 10px rgba(0, 188, 212, 0.4);
        }
        
        .call-btn:hover {
            background: linear-gradient(135deg, #26C6DA 0%, #0097A7 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 188, 212, 0.6);
        }
        
        .call-btn.calling {
            background: linear-gradient(135deg, var(--call) 0%, #0097A7 100%);
            color: white;
            animation: pulse 1s infinite;
            box-shadow: 0 3px 10px rgba(0, 188, 212, 0.6);
        }
        
        .call-btn.active-call {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
            color: white;
            box-shadow: 0 3px 10px rgba(244, 67, 54, 0.6);
        }
        
        .video-call-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #E91E63 0%, #C2185B 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 16px;
            box-shadow: 0 3px 10px rgba(233, 30, 99, 0.4);
        }
        
        .video-call-btn:hover {
            background: linear-gradient(135deg, #F06292 0%, #D81B60 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(233, 30, 99, 0.6);
        }
        
        .video-call-btn.calling {
            background: linear-gradient(135deg, var(--video-call) 0%, #C2185B 100%);
            color: white;
            animation: pulse 1s infinite;
            box-shadow: 0 3px 10px rgba(233, 30, 99, 0.6);
        }
        
        .call-message {
            background: linear-gradient(135deg, var(--call) 0%, #0097A7 100%) !important;
            color: white !important;
            text-align: center;
            padding: 15px !important;
            cursor: default !important;
            border-radius: 20px !important;
            max-width: 85% !important;
        }
        
        .call-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .call-action-btn {
            padding: 12px 25px;
            border-radius: 25px;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .call-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        
        .accept-call-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .accept-call-btn:hover {
            background: linear-gradient(135deg, #66BB6A 0%, #43A047 100%);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        
        .reject-call-btn {
            background: linear-gradient(135deg, #F44336 0%, #D32F2F 100%);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }
        
        .reject-call-btn:hover {
            background: linear-gradient(135deg, #EF5350 0%, #E53935 100%);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.6);
        }
        
        .end-call-btn {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
        }
        
        .call-notification {
            position: fixed;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--call) 0%, #0097A7 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px;
            animation: slideDown 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2000;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 15px 35px rgba(0,188,212,0.5);
            text-align: center;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .call-notification.video {
            background: linear-gradient(135deg, var(--video-call) 0%, #C2185B 100%);
            box-shadow: 0 15px 35px rgba(233, 30, 99, 0.5);
        }
        
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        .call-notification h4 {
            margin-bottom: 10px;
            font-size: 20px;
            font-weight: bold;
        }
        
        .call-notification p {
            margin-bottom: 20px;
            font-size: 16px;
            opacity: 0.9;
        }
        
        .notification-permission {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--warning) 0%, #F57C00 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            z-index: 1500;
            animation: slideIn 0.5s ease;
        }
        
        .notification-permission p {
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .notification-permission-buttons {
            display: flex;
            gap: 10px;
        }
        
        .notification-permission-btn {
            flex: 1;
            padding: 8px 15px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .allow-notifications-btn {
            background: white;
            color: var(--warning);
        }
        
        .later-notifications-btn {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .context-menu {
            position: fixed;
            background: linear-gradient(135deg, var(--sidebar) 0%, #2A1E16 100%);
            border-radius: 15px;
            padding: 10px;
            min-width: 200px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,107,53,0.2);
            z-index: 2000;
            animation: slideUp 0.2s ease;
            max-width: 300px;
        }
        
        .context-menu-item {
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .context-menu-item:hover {
            background: rgba(255,107,53,0.1);
        }
        
        .context-menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.1);
            margin: 5px 0;
        }
        
        .file-download-btn {
            background: rgba(255,107,53,0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 5px;
            display: inline-block;
            transition: all 0.3s;
        }
        
        .file-download-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }
        
        .contact-options-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .contact-options-btn:hover {
            background: rgba(255,107,53,0.1);
            color: var(--primary);
        }
        
        .user-profile-view {
            flex: 1;
            overflow-y: auto;
            padding: 25px;
            background: linear-gradient(135deg, #1A1A1A 0%, #2D1B0E 100%);
        }
        
        .edit-nickname-input {
            background: rgba(255,255,255,0.05);
            border: 2px solid var(--primary);
            border-radius: 10px;
            color: var(--text);
            padding: 8px 12px;
            font-size: 14px;
            width: 100%;
            margin-top: 5px;
        }
        
        .edit-nickname-btn {
            background: rgba(255,107,53,0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 5px;
            transition: all 0.3s;
        }
        
        .edit-nickname-btn:hover {
            background: var(--primary);
            color: white;
        }
        
        .download-progress {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .download-progress-bar {
            height: 100%;
            background: var(--primary);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .call-active-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1A1A1A 0%, #2D1B0E 100%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .call-active-header {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: var(--call);
        }
        
        .call-active-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--call) 0%, #0097A7 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            margin-bottom: 30px;
            border: 5px solid var(--call);
            box-shadow: 0 15px 35px rgba(0,188,212,0.5);
        }
        
        .call-active-name {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .call-active-status {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }
        
        .call-active-timer {
            font-size: 48px;
            font-family: monospace;
            font-weight: bold;
            margin-bottom: 40px;
            color: var(--call);
        }
        
        .call-active-actions {
            display: flex;
            gap: 20px;
        }
        
        .call-active-action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .end-call-active-btn {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
            color: white;
        }
        
        .mute-call-btn {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: white;
        }
        
        .speaker-call-btn {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: white;
        }
        
        .call-active-action-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        .join-call-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            min-width: 160px;
            justify-content: center;
        }
        
        .join-call-btn:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, #66BB6A 0%, #43A047 100%);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        
        .user-status.real-online {
            color: var(--success);
            position: relative;
        }
        
        .user-status.real-online::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: var(--success);
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 1.5s infinite;
        }
        
        .user-status.real-offline {
            color: var(--text-secondary);
        }
        
        .user-status.recently-active {
            color: var(--warning);
        }
        
        .message-sending {
            opacity: 0.8;
            animation: sendingPulse 0.6s infinite alternate;
        }
        
        @keyframes sendingPulse {
            from { opacity: 0.8; }
            to { opacity: 0.4; }
        }
        
        .image-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            backdrop-filter: blur(10px);
        }
        
        .image-preview-content {
            max-width: 90%;
            max-height: 90%;
            position: relative;
        }
        
        .image-preview-content img {
            width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            cursor: zoom-in;
            transition: transform 0.2s;
        }
        
        .image-preview-content img.zoomed {
            transform: scale(1.5);
            cursor: zoom-out;
        }
        
        .image-preview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* Стили для выбора типа звонка */
        .call-type-selector {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 25px;
        }
        
        .call-type-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
            border: 2px solid transparent;
        }
        
        .call-type-option:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-5px);
        }
        
        .call-type-option.selected {
            background: rgba(255,107,53,0.1);
            border-color: var(--primary);
            box-shadow: 0 5px 15px rgba(255,107,53,0.3);
        }
        
        .call-type-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        
        .call-type-name {
            font-size: 16px;
            font-weight: 600;
        }
        
        /* Контейнер для видео */
        .video-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            height: 500px;
            border-radius: 15px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        
        .local-video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            border-radius: 10px;
            border: 3px solid white;
            background: #000;
            object-fit: cover;
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .remote-video {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            background: #000;
            object-fit: cover;
        }
        
        .call-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 20;
        }
        
        /* Кнопка присоединения к звонку в сообщении */
        .join-call-message-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .join-call-message-btn:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, #66BB6A 0%, #43A047 100%);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        /* ЗЕЛЕНЫЙ ИНДИКАТОР ГОВОРЕНИЯ В ЗВОНКЕ */
        .speaking-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            background-color: #4CAF50;
            border-radius: 50%;
            box-shadow: 0 0 10px #4CAF50;
            animation: speakingPulse 1s infinite alternate;
            display: none;
            z-index: 30;
        }

        @keyframes speakingPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 10px #4CAF50;
            }
            100% {
                transform: scale(1.5);
                box-shadow: 0 0 20px #4CAF50;
            }
        }

        .speaking-active {
            display: block;
        }

        /* КНОПКА ОТКЛЮЧЕНИЯ ЗВОНКА */
        .disable-call-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 16px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            margin-left: 5px;
        }

        .disable-call-btn:hover {
            background: linear-gradient(135deg, #777 0%, #555 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .disable-call-btn.active {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
            color: white;
        }

        .call-disabled-message {
            background: linear-gradient(135deg, #666 0%, #444 100%) !important;
            color: white !important;
            text-align: center;
            padding: 15px !important;
            cursor: default !important;
            border-radius: 20px !important;
            max-width: 85% !important;
            font-size: 14px;
            opacity: 0.8;
        }
        
        /* Стили для видео-превью */
        .video-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4001;
            backdrop-filter: blur(10px);
        }
        
        .video-preview-content {
            max-width: 90%;
            max-height: 90%;
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }
        
        .video-preview-content video {
            width: 100%;
            height: auto;
            max-height: 80vh;
            display: block;
        }
        
        .video-preview-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .video-preview-play-btn {
            background: var(--primary);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
        }
        
        .video-preview-progress {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
            overflow: hidden;
        }
        
        .video-preview-progress-filled {
            height: 100%;
            background: var(--primary);
            width: 0%;
        }
        
        .video-preview-time {
            color: white;
            font-size: 14px;
            min-width: 80px;
            text-align: center;
        }
        
        .video-preview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* Показатель качества соединения */
        .connection-quality {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 15;
        }
        
        .connection-quality.good {
            color: #4CAF50;
        }
        
        .connection-quality.fair {
            color: #FF9800;
        }
        
        .connection-quality.poor {
            color: #F44336;
        }
        
        /* Уведомление о больших файлах */
        .file-size-warning {
            color: var(--warning);
            font-size: 12px;
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Индикатор сжатия */
        .compression-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--primary);
            font-size: 12px;
            margin-top: 5px;
        }

        /* Кнопка выбора файла с иконкой */
        .custom-file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
        }

        .custom-file-input input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Прогресс загрузки файла */
        .upload-progress-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 0 0 8px 8px;
            z-index: 10;
        }

        .upload-progress {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .upload-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            transition: width 0.3s ease;
            position: relative;
        }

        .upload-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: uploading 1.5s infinite linear;
        }

        @keyframes uploading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .upload-progress-text {
            font-size: 11px;
            color: white;
            text-align: center;
            font-weight: 600;
        }

        /* Индикатор отправки сообщения */
        .sending-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sending-indicator .loading {
            width: 12px;
            height: 12px;
            border-width: 2px;
        }

        /* Стили для блокировки звонков */
        .call-blocked-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 20px;
        }

        .call-blocked-text {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
        }

        /* Стили для видеосообщений (кружки) */
        .video-circle-message {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            overflow: hidden;
            background: #000;
            position: relative;
            cursor: pointer;
            margin-top: 10px;
            border: 4px solid rgba(255,107,53,0.3);
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .video-circle-message:hover {
            transform: scale(1.03);
            border-color: var(--primary);
            box-shadow: 0 12px 30px rgba(255,107,53,0.2);
        }

        .video-circle-message video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-circle-play-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background: rgba(255,107,53,0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid white;
            z-index: 2;
        }

        .video-circle-play-btn:hover {
            background: rgba(255,107,53,0.9);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .video-circle-duration {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2;
        }

        .video-circle-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.2);
            z-index: 2;
        }

        .video-circle-progress-bar {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.1s;
        }

        /* Модальное окно записи видеосообщения */
        .video-recording-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            backdrop-filter: blur(10px);
        }

        .video-recording-content {
            background: linear-gradient(135deg, var(--sidebar) 0%, #2A1E16 100%);
            border-radius: 20px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            width: 600px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,107,53,0.3);
            display: flex;
            flex-direction: column;
        }

        .video-recording-preview {
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }

        .video-recording-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-recording-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .video-recording-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .record-start-btn {
            background: linear-gradient(135deg, var(--error) 0%, #D32F2F 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }

        .record-start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.6);
        }

        .record-start-btn.recording {
            animation: pulse 1.5s infinite;
        }

        .record-stop-btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255,107,53,0.4);
        }

        .record-stop-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255,107,53,0.6);
        }

        .camera-switch-btn {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .camera-switch-btn:hover {
            background: linear-gradient(135deg, #777 0%, #555 100%);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .video-recording-timer {
            font-size: 32px;
            font-family: monospace;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .video-recording-max-time {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        /* Индикатор записи */
        .recording-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            background: var(--error);
            color: white;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 2;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        /* Кнопка отправки видеосообщений */
        .video-message-btn {
            width: 40px;
            height: 40px;
            background: rgba(233,30,99,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            color: var(--video-call);
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
            font-size: 16px;
            position: relative;
        }

        .video-message-btn:hover {
            background: rgba(233,30,99,0.3);
            color: #F06292;
        }
        
        /* Индикатор загрузки больших видео */
        .video-chunk-info {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .video-chunk-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .video-chunk-progress-bar {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .video-chunk-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            transition: width 0.3s;
        }

        .video-chunk-text {
            font-size: 11px;
            color: var(--primary);
            font-weight: 600;
        }

        /* Кнопки ввода сообщений меньшего размера */
        .compact-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .compact-controls .attach-btn,
        .compact-controls .voice-btn,
        .compact-controls .video-message-btn,
        .compact-controls .send-btn,
        .compact-controls .call-btn,
        .compact-controls .video-call-btn,
        .compact-controls .disable-call-btn {
            width: 36px;
            height: 36px;
            font-size: 15px;
        }

        .compact-controls .message-input {
            padding: 8px 12px;
            font-size: 13px;
            min-height: 36px;
            border-radius: 18px;
        }

        /* Видео-превью с крестиком */
        .video-message-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            backdrop-filter: blur(10px);
        }

        .video-message-preview-content {
            max-width: 90%;
            max-height: 90%;
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: #000;
        }

        .video-message-preview-content video {
            width: 100%;
            height: auto;
            max-height: 80vh;
            display: block;
        }

        .video-message-preview-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        .video-message-preview-close:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }

        /* Уведомление о скачивании файла */
        .download-notification {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, var(--success) 0%, #388E3C 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            z-index: 1500;
            animation: slideInLeft 0.5s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0%); opacity: 1; }
        }

        .download-notification-icon {
            font-size: 24px;
        }

        .download-notification-text {
            flex: 1;
            font-size: 14px;
        }

        /* Push уведомления */
        .push-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            z-index: 1500;
            animation: slideInRight 0.5s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 5px solid var(--primary-light);
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0%); opacity: 1; }
        }

        .push-notification-icon {
            font-size: 24px;
        }

        .push-notification-content {
            flex: 1;
        }

        .push-notification-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .push-notification-message {
            font-size: 13px;
            opacity: 0.9;
        }

        .push-notification-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .push-notification-close:hover {
            background: rgba(255,255,255,0.2);
        }

        /* --- НОВЫЕ СТИЛИ ДЛЯ РЕДАКТИРОВАНИЯ, РЕАКЦИЙ --- */
        .message-actions {
            position: absolute;
            top: -20px;
            right: 10px;
            display: flex;
            gap: 5px;
            background: var(--sidebar);
            border-radius: 20px;
            padding: 4px 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            border: 1px solid rgba(255,107,53,0.3);
        }
        .message:hover .message-actions {
            opacity: 1;
            pointer-events: all;
        }
        .message-action-btn {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.2s;
        }
        .message-action-btn:hover {
            background: rgba(255,107,53,0.3);
            color: var(--primary);
            transform: scale(1.1);
        }
        .message-reactions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .reaction-badge {
            background: rgba(255,255,255,0.1);
            border-radius: 30px;
            padding: 2px 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .reaction-badge:hover {
            background: rgba(255,107,53,0.3);
            border-color: var(--primary);
            transform: scale(1.05);
        }
        .reaction-badge.own-reaction {
            background: rgba(255,107,53,0.4);
            border-color: var(--primary);
        }
        .edit-message-input {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border: 2px solid var(--primary);
            border-radius: 15px;
            color: var(--text);
            font-size: 14px;
            margin: 8px 0;
        }
        .edit-message-actions {
            display: flex;
            gap: 8px;
            margin-top: 5px;
        }

        /* --- НОВЫЕ СТИЛИ: ПОИСК СООБЩЕНИЙ --- */
        .search-messages-container {
            padding: 10px 15px;
            background: rgba(255,107,53,0.05);
            border-bottom: 1px solid rgba(255,107,53,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .search-messages-input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,107,53,0.3);
            border-radius: 30px;
            color: var(--text);
            font-size: 14px;
            outline: none;
        }
        .search-messages-input:focus {
            border-color: var(--primary);
        }
        .search-messages-btn {
            background: none;
            border: none;
            color: var(--primary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
        }
        .search-messages-count {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* --- НОВЫЕ СТИЛИ: КАНАЛЫ --- */
        .channel-info-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,107,53,0.1);
        }
        .channel-avatar-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: var(--channel);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: 800;
            margin: 0 auto 15px;
            color: white;
            border: 4px solid var(--channel);
            box-shadow: 0 10px 25px rgba(139,195,74,0.3);
        }
        .channel-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }
        .channel-subscribe-btn {
            background: linear-gradient(135deg, var(--channel) 0%, #7CB342 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .channel-subscribe-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(139,195,74,0.4);
        }
        .channel-unsubscribe-btn {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid var(--channel);
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .channel-unsubscribe-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        /* Доп. стили для реакций на каналах */
        .message.channel-message {
            border-left: 4px solid var(--channel);
        }

        /* === НОВЫЕ СТИЛИ: ИНДИКАТОРЫ НАБОРА ТЕКСТА И ЗВОНКОВ === */
        .typing-indicator {
            font-size: 13px;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 0;
        }
        .typing-dots {
            display: inline-flex;
            gap: 3px;
        }
        .typing-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--primary-light);
            animation: typingPulse 1.4s infinite;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typingPulse {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-4px); opacity: 1; }
        }

        .call-ringing-indicator {
            font-size: 13px;
            color: var(--call);
            display: flex;
            align-items: center;
            gap: 5px;
            animation: ringingPulse 1s infinite;
        }
        @keyframes ringingPulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.7; }
        }

        /* === НОВЫЕ СТИЛИ: КАСТОМНЫЕ РЕАКЦИИ === */
        .custom-reaction-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .custom-reaction-content {
            background: var(--sidebar);
            padding: 20px;
            border-radius: 20px;
            width: 90%;
            max-width: 400px;
        }
        .custom-reaction-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .custom-reaction-item {
            font-size: 30px;
            cursor: pointer;
            padding: 5px;
            border-radius: 10px;
            transition: all 0.2s;
        }
        .custom-reaction-item:hover {
            background: rgba(255,107,53,0.3);
            transform: scale(1.1);
        }
        .custom-reaction-input {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border: 2px solid var(--primary);
            border-radius: 10px;
            color: white;
            font-size: 20px;
            text-align: center;
            margin-bottom: 15px;
        }
        /* ===== КОНЕЦ СТИЛЕЙ ===== */

        /* === НОВЫЕ СТИЛИ ДЛЯ ПРОГРЕССА ЗАГРУЗКИ ФАЙЛОВ === */
        .upload-progress-message {
            position: relative;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid var(--primary);
            font-size: 12px;
            color: var(--text-secondary);
        }
        .upload-progress-message .progress-bar {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }
        .upload-progress-message .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        /* PDF просмотр */
        .pdf-message {
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--primary);
            max-height: 500px;
            display: flex;
            flex-direction: column;
        }
        .pdf-message iframe {
            width: 100%;
            height: 400px;
            border: none;
        }
        .pdf-message .pdf-controls {
            background: var(--sidebar);
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--primary);
        }
        /* Стили для любого документа */
        .doc-preview {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 10px;
            border-left: 4px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .doc-preview .doc-icon {
            font-size: 32px;
        }
        .doc-preview .doc-info {
            flex: 1;
        }
    </style>
</head>
<body>
    <!-- ЭКРАН АВТОРИЗАЦИИ -->
    <div id="authScreen" class="screen">
        <div class="auth-form">
            <div class="logo">
                <div class="logo-icon">A</div>
                <h2>AbSgram</h2>
                <p>Видеозвонки через</p>
            </div>
            
            <div id="loginForm">
                <h3 style="text-align: center; margin-bottom: 25px;">Вход в аккаунт</h3>
                <div class="input-group">
                    <label for="loginUsername">Никнейм</label>
                    <input type="text" id="loginUsername" placeholder="Ваш никнейм">
                </div>
                <div class="input-group">
                    <label for="loginPassword">Пароль</label>
                    <input type="password" id="loginPassword" placeholder="••••••">
                </div>
                <button class="btn" style="width: 100%; margin-top: 10px;" id="loginBtn">
                    <span>Войти</span>
                </button>
                <div class="auth-toggle">
                    Нет аккаунта? <a id="showRegisterBtn">Зарегистрироваться</a>
                </div>
            </div>
            
            <div id="registerForm" class="hidden">
                <h3 style="text-align: center; margin-bottom: 25px;">Регистрация</h3>
                <div class="input-group">
                    <label for="registerName">Имя</label>
                    <input type="text" id="registerName" placeholder="Ваше имя">
                </div>
                <div class="input-group">
                    <label for="registerUsername">Никнейм</label>
                    <input type="text" id="registerUsername" placeholder="Латинские буквы, цифры, _">
                </div>
                <div class="input-group">
                    <label for="registerPassword">Пароль (мин. 6 символов)</label>
                    <input type="password" id="registerPassword" placeholder="••••••">
                </div>
                <button class="btn" style="width: 100%; margin-top: 10px;" id="registerBtn">
                    <span>Зарегистрироваться</span>
                </button>
                <div class="auth-toggle">
                    Уже есть аккаунт? <a id="showLoginBtn">Войти</a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- СПИСОК ЧАТОВ -->
    <div id="chatsScreen" class="screen hidden">
        <div class="header">
            <div class="header-title">AbSgram</div>
            <button class="btn" id="profileBtn">👤 Профиль</button>
        </div>
        
        <!-- ПОИСК ПОЛЬЗОВАТЕЛЕЙ И КАНАЛОВ -->
        <div class="search-container">
            <input type="text" class="search-input" id="searchUsersInput" placeholder="Поиск пользователей, каналов или ссылка..." autocomplete="off">
        </div>
        
        <div class="chats-list" id="chatsList">
            <div class="empty-state">
                <div class="icon">💬</div>
                <p>Загрузка чатов...</p>
            </div>
        </div>
        <button class="new-chat-btn" id="newChatBtn">+</button>
    </div>
    
    <!-- ЭКРАН ЧАТА -->
    <div id="chatScreen" class="screen hidden">
        <div class="header">
            <button class="back-btn" id="backToChatsBtn">←</button>
            <div style="flex: 1; padding: 0 10px;">
                <div id="chatTitle" style="font-weight: bold; font-size: 16px;"></div>
                <div id="chatStatus" style="font-size: 13px;"></div>
                <div id="typingStatus" class="typing-indicator hidden">
                    <span>печатает</span>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
                <div id="callRingingStatus" class="call-ringing-indicator hidden">
                    🔔 Входящий звонок...
                </div>
            </div>
            <button class="btn" id="groupInfoBtn" style="display: none;">👥 Инфо</button>
            <button class="btn" id="channelInfoBtn" style="display: none;">📢 Инфо</button>
            <div class="compact-controls">
                <button class="video-call-btn" id="videoCallBtn" title="HD Видеозвонок" style="display: none;">📹</button>
                <button class="call-btn" id="callBtn" title="HD Аудиозвонок" style="display: none;">📞</button>
                <button class="disable-call-btn" id="disableCallBtn" title="Отключить звонки" style="display: none;">🔕</button>
                <button class="contact-options-btn" id="contactOptionsBtn" title="Опции контакта" style="display: none;">⋮</button>
            </div>
        </div>
        
        <!-- ПОИСК ПО СООБЩЕНИЯМ -->
        <div class="search-messages-container" id="searchMessagesContainer">
            <input type="text" class="search-messages-input" id="searchMessagesInput" placeholder="🔍 Поиск в чате...">
            <span class="search-messages-count" id="searchMessagesCount"></span>
            <button class="search-messages-btn" id="prevSearchBtn">▲</button>
            <button class="search-messages-btn" id="nextSearchBtn">▼</button>
        </div>

        <!-- ИНДИКАТОР ОТВЕТА -->
        <div id="replyingIndicator" class="replying-indicator hidden">
            <span>Ответ на сообщение: <span id="replyToText">...</span></span>
            <span class="cancel-reply" id="cancelReplyBtn">×</span>
        </div>
        
        <div class="messages-container" id="messagesContainer">
            <div class="empty-state">
                <div class="icon">💭</div>
                <p>Начните общение!</p>
                <p style="font-size: 14px; margin-top: 10px;">Отправьте первое сообщение</p>
            </div>
        </div>
        <div class="message-input-container">
            <div class="compact-controls">
                <button class="attach-btn" id="attachBtn">📎</button>
                <button class="voice-btn" id="voiceBtn">
                    🎤
                    <div class="recording-time" id="recordingTime" style="display: none;">0:00</div>
                </button>
                <button class="video-message-btn" id="videoMessageBtn" title="Видеосообщение">
                    📹
                </button>
                <textarea class="message-input" id="messageInput" placeholder="Введите сообщение..." rows="1"></textarea>
                <button class="send-btn" id="sendMessageBtn" disabled>➤</button>
            </div>
        </div>
    </div>
    
    <!-- ПРОФИЛЬ -->
    <div id="profileScreen" class="screen hidden">
        <div class="header">
            <button class="back-btn" id="backToChatsBtn2">←</button>
            <div class="header-title">Профиль</div>
            <div style="width: 40px;"></div>
        </div>
        <div class="profile-content">
            <div class="profile-header">
                <div class="profile-avatar-container" id="profileAvatarContainer">
                    <div class="profile-avatar" id="profileAvatar"></div>
                    <div class="avatar-upload" id="showAvatarModalBtn" title="Сменить аватарку">✎</div>
                </div>
                <div class="profile-name" id="profileName"></div>
                <div class="profile-username" id="profileUsername"></div>
                <div class="profile-status" id="profileStatus">
                    <span class="status-dot"></span>
                    <span>online</span>
                </div>
            </div>
            
            <div class="info-section">
                <h3>Информация</h3>
                <div class="info-item">
                    <div class="info-label">Никнейм</div>
                    <div class="info-value" id="profileUsernameValue"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">ID пользователя</div>
                    <div class="info-value" id="profileId"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">Дата регистрации</div>
                    <div class="info-value" id="profileDate"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">Всего чатов</div>
                    <div class="info-value" id="profileChatsCount">0</div>
                </div>
            </div>

            <!-- ИСТОРИЯ (ПОСТЫ) -->
            <div class="info-section">
                <h3>📝 Моя история</h3>
                <div id="profilePostsList" class="group-members-list" style="justify-content: flex-start; min-height: 50px;">
                    <div style="color: var(--text-secondary); text-align: center; width: 100%;">У вас пока нет постов</div>
                </div>
                <button class="btn" style="width: 100%; margin-top: 10px;" id="createPostBtn">➕ Добавить пост</button>
            </div>
            
            <button class="btn" style="width: 100%; margin-top: 20px;" id="editNameBtn">
                ✏️ Изменить имя
            </button>
            <button class="btn btn-secondary" style="width: 100%; margin-top: 10px;" id="logoutBtn">
                🚪 Выйти из аккаунта
            </button>
        </div>
    </div>
    
    <!-- ПРОСМОТР ПРОФИЛЯ ПОЛЬЗОВАТЕЛЯ -->
    <div id="userProfileScreen" class="screen hidden">
        <div class="header">
            <button class="back-btn" id="backFromUserProfileBtn">←</button>
            <div class="header-title">Профиль пользователя</div>
            <div style="width: 40px;"></div>
        </div>
        <div class="user-profile-view" id="userProfileContent">
            <div class="empty-state">
                <div class="loading"></div>
                <p style="margin-top: 10px;">Загрузка профиля...</p>
            </div>
        </div>
    </div>
    
    <!-- ЭКРАН ВЫБОРА ТИПА ЗВОНКА -->
    <div id="callTypeModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Выберите тип звонка</div>
            
            <div class="call-type-selector">
                <div class="call-type-option" id="audioCallOption" data-type="audio">
                    <div class="call-type-icon">📞</div>
                    <div class="call-type-name">HD Аудиозвонок</div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">Только звук</div>
                </div>
                <div class="call-type-option" id="videoCallOption" data-type="video">
                    <div class="call-type-icon">📹</div>
                    <div class="call-type-name">HD Видеозвонок</div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">Звук + видео</div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="cancelCallTypeBtn">Отмена</button>
                <button class="btn" style="flex: 1;" id="startCallWithTypeBtn">Начать звонок</button>
            </div>
        </div>
    </div>
    
    <!-- ЭКРАН АКТИВНОГО ЗВОНКА -->
    <div id="callActiveScreen" class="call-active-screen hidden">
        <div class="call-active-header">
            <span id="callTypeIcon">📞</span> HD Звонок
            <div class="speaking-indicator" id="speakingIndicator"></div>
            <div class="connection-quality" id="connectionQuality">📶 Соединение...</div>
        </div>
        
        <div class="video-container" id="videoContainer" style="display: none;">
            <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
            <video id="localVideo" class="local-video" autoplay playsinline muted></video>
            <div class="call-controls">
                <button class="call-active-action-btn mute-call-btn" id="muteCallBtnVideo" title="Выключить микрофон">
                    🎤
                </button>
                <button class="call-active-action-btn end-call-active-btn" id="endCallActiveBtnVideo" title="Завершить звонок">
                    📞
                </button>
                <button class="call-active-action-btn speaker-call-btn" id="speakerCallBtnVideo" title="Включить громкую связь">
                    🔊
                </button>
                <button class="call-active-action-btn" id="videoToggleBtn" title="Выключить видео">
                    📹
                </button>
            </div>
        </div>
        
        <div id="audioCallContainer">
            <div class="call-active-avatar" id="callActiveAvatar">
                👤
            </div>
            <div class="call-active-name" id="callActiveName">
                Иван Иванов
            </div>
            <div class="call-active-status" id="callActiveStatus">
                Идет разговор...
            </div>
            <div class="call-active-timer" id="callActiveTimer">
                00:00
            </div>
            <div class="call-active-actions">
                <button class="call-active-action-btn mute-call-btn" id="muteCallBtnAudio" title="Выключить микрофон">
                    🎤
                </button>
                <button class="call-active-action-btn end-call-active-btn" id="endCallActiveBtnAudio" title="Завершить звонок">
                    📞
                </button>
                <button class="call-active-action-btn speaker-call-btn" id="speakerCallBtnAudio" title="Включить громкую связь">
                    🔊
                </button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛКА ДЛЯ АВАТАРКИ -->
    <div id="avatarModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Сменить аватарку</div>
            
            <div class="avatar-preview" id="avatarPreview"></div>
            
            <div class="avatar-options">
                <div class="avatar-option" style="background: #FF6B35;" data-color="#FF6B35" title="Оранжевый">A</div>
                <div class="avatar-option" style="background: #FF8E53;" data-color="#FF8E53" title="Светло-оранжевый">B</div>
                <div class="avatar-option" style="background: #FFB347;" data-color="#FFB347" title="Желто-оранжевый">C</div>
                <div class="avatar-option" style="background: #FF7043;" data-color="#FF7043" title="Терракотовый">D</div>
                <div class="avatar-option" style="background: #FF9E6D;" data-color="#FF9E6D" title="Персиковый">E</div>
                <div class="avatar-option" style="background: #FFCC99;" data-color="#FFCC99" title="Песочный">F</div>
            </div>
            
            <div class="avatar-upload-area" id="uploadAvatarBtn">
                <div style="font-size: 30px; margin-bottom: 10px;">📁</div>
                <div>Загрузить фотографию</div>
                <div style="font-size: 12px; color: #aaa; margin-top: 5px;">JPG, PNG до 10MB</div>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="cancelAvatarBtn">Отмена</button>
                <button class="btn" style="flex: 1;" id="saveAvatarBtn">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛКА ДЛЯ НОВОГО ЧАТА/ГРУППЫ/КАНАЛА -->
    <div id="newChatModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Новый чат</div>
            
            <div class="modal-tabs">
                <div class="modal-tab active" data-tab="single">Личный</div>
                <div class="modal-tab" data-tab="group">Группа</div>
                <div class="modal-tab" data-tab="channel">Канал</div>
            </div>
            
            <!-- ВКЛАДКА ЛИЧНОГО ЧАТА -->
            <div id="singleTab" class="tab-content active">
                <div class="search-container" style="border: none; padding: 0 0 15px 0;">
                    <input type="text" class="search-input" id="singleSearchInput" placeholder="Поиск пользователей..." autocomplete="off">
                </div>
                <div id="singleSearchResults" class="users-list" style="padding: 0; max-height: 300px;"></div>
            </div>
            
            <!-- ВКЛАДКА СОЗДАНИЯ ГРУППЫ -->
            <div id="groupTab" class="tab-content">
                <div class="input-group">
                    <label for="groupName">Название группы</label>
                    <input type="text" id="groupName" placeholder="Введите название группы">
                </div>
                
                <div class="input-group">
                    <label>Поиск участников</label>
                    <input type="text" class="search-input" id="groupSearchInput" placeholder="Поиск пользователей..." autocomplete="off">
                </div>
                
                <div id="groupSearchResults" class="users-list" style="padding: 0; max-height: 200px; margin-bottom: 15px;"></div>
                
                <div class="input-group">
                    <label>Выбранные участники (<span id="memberCount">0</span>)</label>
                    <div class="group-members" id="groupMembersList">
                        <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                            Добавьте участников из списка выше
                        </div>
                    </div>
                </div>
                
                <button class="btn create-group-btn" id="createGroupBtn" disabled>
                    👥 Создать группу
                </button>
            </div>
            
            <!-- ВКЛАДКА СОЗДАНИЯ КАНАЛА -->
            <div id="channelTab" class="tab-content">
                <div class="input-group">
                    <label for="channelName">Название канала</label>
                    <input type="text" id="channelName" placeholder="Введите название канала">
                </div>
                <div class="input-group">
                    <label for="channelDescription">Описание (необязательно)</label>
                    <input type="text" id="channelDescription" placeholder="О чем ваш канал?">
                </div>
                <div class="input-group">
                    <label>Тип канала</label>
                    <select id="channelType" class="search-input" style="padding: 12px;">
                        <option value="public">🔓 Публичный (все могут найти)</option>
                        <option value="private">🔒 Приватный (только по ссылке)</option>
                    </select>
                </div>
                <button class="btn create-group-btn" id="createChannelBtn" style="margin-top: 20px;">
                    📢 Создать канал
                </button>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="cancelGroupBtn">Отмена</button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛКА ДЛЯ ИНФОРМАЦИИ О ГРУППЕ -->
    <div id="groupInfoModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Информация о группе</div>
            
            <div class="group-info-header">
                <div class="group-avatar-large" id="groupInfoAvatar">👥</div>
                <h3 id="groupInfoName"></h3>
                <div style="color: var(--text-secondary); margin-top: 5px;" id="groupInfoMembers"></div>
            </div>
            
            <div class="info-section">
                <h3>Участники</h3>
                <div class="group-members-list" id="groupInfoMembersList">
                    <!-- Участники будут добавлены динамически -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="closeGroupInfoBtn">Закрыть</button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛКА ДЛЯ ИНФОРМАЦИИ О КАНАЛЕ -->
    <div id="channelInfoModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Информация о канале</div>
            
            <div class="channel-info-header">
                <div class="channel-avatar-large" id="channelInfoAvatar">📢</div>
                <h3 id="channelInfoName"></h3>
                <div style="color: var(--text-secondary); margin-top: 5px;" id="channelInfoDescription"></div>
                <div class="channel-stats">
                    <span id="channelInfoSubscribers">👥 0 подписчиков</span>
                    <span id="channelInfoPosts">📝 0 постов</span>
                </div>
                <div>
                    <button class="channel-subscribe-btn" id="channelSubscribeBtn">Подписаться</button>
                    <button class="channel-unsubscribe-btn" id="channelUnsubscribeBtn" style="display: none;">Отписаться</button>
                </div>
                <div style="margin-top: 10px;">
                    <span id="channelInviteLink" style="color: var(--primary-light); font-size: 12px;"></span>
                </div>
            </div>
            
            <div class="info-section" id="channelAdminSection" style="display: none;">
                <h3>Управление</h3>
                <button class="btn" style="width: 100%; margin-bottom: 10px;" id="editChannelBtn">✏️ Редактировать канал</button>
                <button class="btn btn-secondary" style="width: 100%;" id="deleteChannelBtn">🗑️ Удалить канал</button>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="closeChannelInfoBtn">Закрыть</button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛЬНОЕ ОКНО ДЛЯ ЗАПИСИ ВИДЕОСООБЩЕНИЙ (ИСПРАВЛЕНО) -->
    <div id="videoRecordingModal" class="video-recording-modal hidden">
        <div class="video-recording-content">
            <div class="modal-title">Запись видеосообщения</div>
            
            <div class="video-recording-max-time">
                Максимальная длительность: 60 секунд
            </div>
            
            <div class="video-recording-timer" id="videoRecordingTimer">00:00</div>
            
            <div class="video-recording-preview">
                <video id="videoRecordingPreview" autoplay muted></video>
                <div id="recordingIndicator" class="recording-indicator" style="display: none;">
                    <div class="recording-dot"></div>
                    Запись...
                </div>
            </div>
            
            <div class="video-recording-controls">
                <button class="camera-switch-btn video-recording-btn" id="cameraSwitchBtn" title="Переключить камеру">
                    🔄
                </button>
                <button class="record-start-btn video-recording-btn" id="recordStartBtn">
                    ⏺️
                </button>
                <button class="record-stop-btn video-recording-btn" id="recordStopBtn" style="display: none;">
                    ⏹️
                </button>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" style="flex: 1;" id="cancelVideoRecordingBtn">Отмена</button>
                <button class="btn" style="flex: 1;" id="sendVideoMessageBtn">➤ Отправить</button>
            </div>
        </div>
    </div>
    
    <!-- КОНТЕКСТНОЕ МЕНЮ -->
    <div id="contextMenu" class="context-menu hidden">
        <div class="context-menu-item" id="viewProfileBtn">
            <span>👁️</span>
            <span>Просмотреть профиль</span>
        </div>
        <div class="context-menu-item" id="editNicknameBtn">
            <span>✏️</span>
            <span>Изменить имя</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="clearChatBtn">
            <span>🗑️</span>
            <span>Очистить чат</span>
        </div>
        <div class="context-menu-item" id="deleteChatBtn">
            <span>❌</span>
            <span>Удалить чат</span>
        </div>
    </div>
    
    <!-- УВЕДОМЛЕНИЕ О ЗВОНКЕ -->
    <div id="callNotification" class="call-notification hidden">
        <h4 id="callNotificationIcon">📞 Входящий звонок</h4>
        <p id="callerName">Неизвестный абонент</p>
        <p id="callTypeText" style="font-size: 14px; opacity: 0.8;">Аудиозвонок</p>
        <div class="call-actions">
            <button class="call-action-btn accept-call-btn" id="acceptCallBtn">📞 Принять</button>
            <button class="call-action-btn reject-call-btn" id="rejectCallBtn">❌ Отклонить</button>
        </div>
    </div>
    
    <!-- ЗАПРОС РАЗРЕШЕНИЯ НА УВЕДОМЛЕНИЯ -->
    <div id="notificationPermission" class="notification-permission hidden">
        <p>🔔 Разрешить уведомления о новых сообщениях и звонках?</p>
        <div class="notification-permission-buttons">
            <button class="notification-permission-btn allow-notifications-btn" id="allowNotificationsBtn">Разрешить</button>
            <button class="notification-permission-btn later-notifications-btn" id="laterNotificationsBtn">Позже</button>
        </div>
    </div>
    
    <!-- ПРЕВЬЮ ИЗОБРАЖЕНИЙ -->
    <div id="imagePreviewModal" class="image-preview-modal hidden">
        <div class="image-preview-content">
            <img id="previewedImage" src="" alt="" onclick="this.classList.toggle('zoomed')">
            <button class="image-preview-close" id="closeImagePreviewBtn">×</button>
        </div>
    </div>
    
    <!-- ПРЕВЬЮ ВИДЕО -->
    <div id="videoPreviewModal" class="video-preview-modal hidden">
        <div class="video-preview-content">
            <video id="previewedVideo" controls>
                Ваш браузер не поддерживает воспроизведение видео.
            </video>
            <button class="video-preview-close" id="closeVideoPreviewBtn">×</button>
        </div>
    </div>

    <!-- ПРЕВЬЮ ВИДЕОСООБЩЕНИЙ С КРЕСТИКОМ -->
    <div id="videoMessagePreviewModal" class="video-message-preview-modal hidden">
        <div class="video-message-preview-content">
            <video id="videoMessagePreview" controls>
                Ваш браузер не поддерживает воспроизведение видео.
            </video>
            <button class="video-message-preview-close" id="closeVideoMessagePreviewBtn">×</button>
        </div>
    </div>

    <!-- МОДАЛКА ДЛЯ КАСТОМНОЙ РЕАКЦИИ -->
    <div id="customReactionModal" class="custom-reaction-modal hidden">
        <div class="custom-reaction-content">
            <div class="modal-title">Выбери свой смайлик</div>
            <input type="text" class="custom-reaction-input" id="customReactionInput" placeholder="Введи свой смайлик (например: 🚀)" maxlength="10">
            <div class="custom-reaction-grid">
                <div class="custom-reaction-item">👍</div>
                <div class="custom-reaction-item">❤️</div>
                <div class="custom-reaction-item">😂</div>
                <div class="custom-reaction-item">😮</div>
                <div class="custom-reaction-item">😢</div>
                <div class="custom-reaction-item">👎</div>
                <div class="custom-reaction-item">🔥</div>
                <div class="custom-reaction-item">🎉</div>
                <div class="custom-reaction-item">💯</div>
                <div class="custom-reaction-item">🤔</div>
                <div class="custom-reaction-item">😡</div>
                <div class="custom-reaction-item">🥳</div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="cancelCustomReactionBtn">Отмена</button>
                <button class="btn" id="applyCustomReactionBtn">Ок</button>
            </div>
        </div>
    </div>
    
    <!-- СКРЫТЫЕ ИНПУТЫ -->
    <input type="file" id="avatarUpload" accept="image/*" style="display: none;">
    <input type="file" id="fileUpload" accept="*/*" multiple style="display: none;">
    
    <!-- ОВЕРЛЕЙ ЗАГРУЗКИ -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading"></div>
    </div>
    
    <!-- АУДИО ЭЛЕМЕНТ ДЛЯ ВОСПРОИЗВЕДЕНИЯ ГОЛОСОВЫХ -->
    <audio id="audioPlayer" style="display: none;"></audio>
    <audio id="ringtone" loop style="display: none;">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-phone-call-ringing-1106.mp3" type="audio/mpeg">
    </audio>

    <script type="module">
    // ==================== ИМПОРТ FIREBASE v9 ====================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { 
        getAuth, 
        createUserWithEmailAndPassword, 
        signInWithEmailAndPassword, 
        signOut, 
        onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
    import { 
        getFirestore, 
        collection, 
        doc, 
        setDoc, 
        getDoc, 
        getDocs, 
        updateDoc, 
        addDoc, 
        deleteDoc,
        query, 
        where, 
        orderBy, 
        onSnapshot, 
        serverTimestamp,
        limit,
        arrayUnion,
        arrayRemove,
        increment,
        writeBatch
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

    // ==================== КОНФИГУРАЦИЯ FIREBASE ====================
    const firebaseConfig = {
        apiKey: "AIzaSyBRNl0xA5ie8EGcZ4UIdP0e1IJuacoMarE",
        authDomain: "gocklain-bf553.firebaseapp.com",
        projectId: "gocklain-bf553",
        storageBucket: "gocklain-bf553.firebasestorage.app",
        messagingSenderId: "747181228665",
        appId: "1:747181228665:web:bd9dd2cd60b1cd5bb8caa8",
        measurementId: "G-1LBP6KFPL9"
    };

    // ==================== ИНИЦИАЛИЗАЦИЯ FIREBASE ====================
    let app, auth, db;
    let authError = false;

    try {
        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        console.log("✅ Firebase инициализирован");
    } catch (error) {
        console.error("❌ Ошибка инициализации Firebase:", error);
        authError = true;
        showNotification("Ошибка подключения к серверу. Работаем в локальном режиме.", "warning");
    }

    // ==================== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ====================
    let currentUser = null;
    let currentChat = null;
    let selectedAvatar = null;
    let selectedAvatarColor = null;
    let unsubscribeChats = null;
    let unsubscribeMessages = null;
    let allUsers = new Map();
    let searchTimeout = null;
    let allUsersCache = new Map();
    let groupMembers = new Map();
    let isSendingMessage = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let recordingStartTime = null;
    let recordingTimer = null;
    let activeCall = null;
    let callTimer = null;
    let callStartTime = null;
    let notificationPermissionAsked = false;
    let userNicknames = new Map();
    let viewedUserProfile = null;
    let contextMenuTarget = null;
    let notificationCheckInterval = null;
    let onlineStatusInterval = null;
    let selectedCallType = 'audio';
    let unreadCounts = new Map();
    let currentMessageSearch = { index: 0, results: [] };
    
    // WebRTC переменные
    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let isMuted = false;
    let isSpeakerOn = false;
    let isVideoOn = true;
    let currentCallId = null;
    let isCallDisabled = false;
    let speakingIndicatorInterval = null;
    let callListeners = new Map(); // Для хранения unsubscribe функций звонков
    let typingTimeouts = new Map();
    let incomingCallData = null;
    
    // Переменные для видеосообщений
    let videoMediaRecorder = null;
    let videoChunks = [];
    let isVideoRecording = false;
    let videoRecordingStartTime = null;
    let videoRecordingTimer = null;
    let currentCamera = 'user';
    let videoStream = null;
    let maxVideoDuration = 60;
    let maxVideoSize = 50 * 1024 * 1024; // 50MB
    let currentFileUploads = new Map(); // Для отслеживания загрузки файлов
    let currentChunkedUploads = new Map(); // Для отслеживания загрузки больших файлов по частям

    // ==================== НОВЫЕ ПЕРЕМЕННЫЕ ====================
    let messageReactions = new Map(); // messageId -> { count, users }
    let currentlyEditingMessage = null;
    let channels = new Map(); // channelId -> channel data
    let userSubscriptions = new Set(); // channel IDs, которые подписан пользователь
    let typingListeners = new Map(); // Слушатели набора текста
    let callRingingListeners = new Map(); // Слушатели входящих звонков
    let currentReplyTo = null; // { id, text, senderName, type, fileData? }
    let posts = new Map(); // Посты в истории (userId -> [post])

    // ==================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ====================
    function showLoading(show) {
        const overlay = document.getElementById('loadingOverlay');
        overlay.classList.toggle('hidden', !show);
    }

    function showNotification(message, type = 'info') {
        const oldNotifications = document.querySelectorAll('.notification');
        oldNotifications.forEach(n => n.remove());

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    function showPushNotification(title, message) {
        if (!("Notification" in window)) {
            showNotification(message, 'info');
            return;
        }

        if (Notification.permission === "granted") {
            const pushNotification = document.createElement('div');
            pushNotification.className = 'push-notification';
            pushNotification.innerHTML = `
                <div class="push-notification-icon">🔔</div>
                <div class="push-notification-content">
                    <div class="push-notification-title">${title}</div>
                    <div class="push-notification-message">${message}</div>
                </div>
                <button class="push-notification-close">×</button>
            `;
            document.body.appendChild(pushNotification);
            
            pushNotification.querySelector('.push-notification-close').onclick = () => {
                pushNotification.remove();
            };
            
            setTimeout(() => {
                if (pushNotification.parentNode) {
                    pushNotification.style.animation = 'slideInRight 0.3s ease reverse';
                    setTimeout(() => pushNotification.remove(), 300);
                }
            }, 5000);
        } else {
            showNotification(`${title}: ${message}`, 'info');
        }
    }

    function showDownloadNotification(fileName) {
        const notification = document.createElement('div');
        notification.className = 'download-notification';
        notification.innerHTML = `
            <div class="download-notification-icon">✅</div>
            <div class="download-notification-text">Файл "${fileName}" скачан</div>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideInLeft 0.3s ease reverse';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById(screenId).classList.remove('hidden');
    }

    function getRandomColor() {
        const colors = ['#FF6B35', '#FF8E53', '#FF9E6D', '#FFB347', '#FFCC99', '#FF7043'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    function formatDate(date) {
        if (!date) return 'Не указана';
        const d = date?.toDate ? date.toDate() : new Date(date);
        return d.toLocaleDateString('ru-RU', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    }

    function formatTime(date) {
        if (!date) return '';
        const d = date?.toDate ? date.toDate() : new Date(date);
        return d.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function getFileIcon(fileType) {
        if (fileType.startsWith('image/')) return '🖼️';
        if (fileType.startsWith('video/')) return '🎬';
        if (fileType.includes('pdf')) return '📄';
        if (fileType.includes('zip') || fileType.includes('rar') || fileType.includes('7z')) return '📦';
        if (fileType.includes('doc') || fileType.includes('txt') || fileType.includes('text')) return '📝';
        if (fileType.includes('audio') || fileType.includes('music') || fileType.includes('sound')) return '🎵';
        return '📎';
    }

    function formatLastSeen(date) {
        const now = new Date();
        const diffMinutes = Math.floor((now - date) / (1000 * 60));
        
        if (diffMinutes < 1) {
            return 'только что';
        } else if (diffMinutes < 60) {
            return `${diffMinutes} мин назад`;
        } else if (diffMinutes < 1440) {
            const hours = Math.floor(diffMinutes / 60);
            return `${hours} ч назад`;
        } else {
            const days = Math.floor(diffMinutes / 1440);
            return `${days} дн назад`;
        }
    }

    function getUserDisplayName(user) {
        if (!user) return 'Неизвестный';
        const nickname = userNicknames.get(user.id);
        if (nickname) return nickname;
        return user.name || 'Неизвестный';
    }

    function saveUserNickname(userId, nickname) {
        if (!currentUser) return;
        
        try {
            const key = `absgram_nickname_${currentUser.id}_${userId}`;
            if (nickname) {
                localStorage.setItem(key, nickname);
                userNicknames.set(userId, nickname);
            } else {
                localStorage.removeItem(key);
                userNicknames.delete(userId);
            }
        } catch (error) {
            console.error('Ошибка сохранения никнейма:', error);
        }
    }

    function loadAllNicknames() {
        if (!currentUser) return;
        
        try {
            userNicknames.clear();
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(`absgram_nickname_${currentUser.id}_`)) {
                    const userId = key.replace(`absgram_nickname_${currentUser.id}_`, '');
                    const nickname = localStorage.getItem(key);
                    userNicknames.set(userId, nickname);
                }
            }
        } catch (error) {
            console.error('Ошибка загрузки никнеймов:', error);
        }
    }

    // ==================== ОСНОВНЫЕ ФУНКЦИИ ====================
    function initEventListeners() {
        // Авторизация
        document.getElementById('loginBtn').addEventListener('click', login);
        document.getElementById('registerBtn').addEventListener('click', register);
        document.getElementById('showRegisterBtn').addEventListener('click', showRegister);
        document.getElementById('showLoginBtn').addEventListener('click', showLogin);

        // Навигация
        document.getElementById('profileBtn').addEventListener('click', showProfile);
        document.getElementById('newChatBtn').addEventListener('click', showNewChatModal);
        document.getElementById('backToChatsBtn').addEventListener('click', backToChats);
        document.getElementById('backToChatsBtn2').addEventListener('click', backToChats);
        document.getElementById('backFromUserProfileBtn').addEventListener('click', () => {
            showScreen('chatScreen');
        });

        // Поиск
        document.getElementById('searchUsersInput').addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            searchTimeout = setTimeout(() => {
                searchUsersAndChannels(query);
            }, 300);
        });

        document.getElementById('singleSearchInput').addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            searchTimeout = setTimeout(() => {
                searchUsersForChat(query, 'single');
            }, 300);
        });

        document.getElementById('groupSearchInput').addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            searchTimeout = setTimeout(() => {
                searchUsersForChat(query, 'group');
            }, 300);
        });

        // Сообщения
        document.getElementById('sendMessageBtn').addEventListener('click', sendMessage);
        document.getElementById('attachBtn').addEventListener('click', () => {
            document.getElementById('fileUpload').click();
        });

        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            
            const sendBtn = document.getElementById('sendMessageBtn');
            sendBtn.disabled = this.value.trim() === '';
            
            if (!authError && currentChat && !currentChat.isGroup && !currentChat.isChannel) {
                updateTypingStatus(this.value.trim() !== '');
            }
        });

        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Видеосообщения
        document.getElementById('videoMessageBtn').addEventListener('click', startVideoRecording);
        document.getElementById('recordStartBtn').addEventListener('click', startRecordingVideo);
        document.getElementById('recordStopBtn').addEventListener('click', stopRecordingVideo);
        document.getElementById('cameraSwitchBtn').addEventListener('click', switchCamera);
        document.getElementById('cancelVideoRecordingBtn').addEventListener('click', closeVideoRecordingModal);
        document.getElementById('sendVideoMessageBtn').addEventListener('click', sendVideoMessage);

        // Профиль
        document.getElementById('editNameBtn').addEventListener('click', editName);
        document.getElementById('logoutBtn').addEventListener('click', logout);
        document.getElementById('showAvatarModalBtn').addEventListener('click', showAvatarModal);
        document.getElementById('createPostBtn').addEventListener('click', createPost);

        // Аватарка
        document.getElementById('avatarUpload').addEventListener('change', function(e) {
            handleAvatarUpload(e.target.files[0]);
        });

        // Файлы
        document.getElementById('fileUpload').addEventListener('change', function(e) {
            handleFileUpload(e.target.files);
        });

        // Модальные окна
        document.getElementById('cancelAvatarBtn').addEventListener('click', closeAvatarModal);
        document.getElementById('saveAvatarBtn').addEventListener('click', saveAvatar);
        document.getElementById('uploadAvatarBtn').addEventListener('click', () => {
            document.getElementById('avatarUpload').click();
        });

        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', function() {
                selectAvatar(this.dataset.color);
            });
        });

        // Группы
        document.getElementById('createGroupBtn').addEventListener('click', createGroup);
        document.getElementById('createChannelBtn').addEventListener('click', createChannel);
        document.getElementById('cancelGroupBtn').addEventListener('click', closeGroupModal);
        document.getElementById('groupInfoBtn').addEventListener('click', showGroupInfo);
        document.getElementById('channelInfoBtn').addEventListener('click', showChannelInfo);
        document.getElementById('closeGroupInfoBtn').addEventListener('click', closeGroupInfoModal);
        document.getElementById('closeChannelInfoBtn').addEventListener('click', closeChannelInfoModal);

        document.querySelectorAll('.modal-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabType = this.dataset.tab;
                switchTab(tabType);
            });
        });

        // Голосовые сообщения
        const voiceBtn = document.getElementById('voiceBtn');
        voiceBtn.addEventListener('mousedown', startVoiceRecording);
        voiceBtn.addEventListener('touchstart', startVoiceRecording);
        voiceBtn.addEventListener('mouseup', stopVoiceRecording);
        voiceBtn.addEventListener('touchend', stopVoiceRecording);
        voiceBtn.addEventListener('mouseleave', stopVoiceRecording);

        document.getElementById('disableCallBtn').addEventListener('click', toggleCallsDisabled);

        // Звонки
        document.getElementById('callBtn').addEventListener('click', () => {
            if (isCallDisabled) {
                showNotification('Звонки отключены. Включите их в настройках.', 'warning');
                return;
            }
            showCallTypeModal();
        });

        document.getElementById('videoCallBtn').addEventListener('click', () => {
            if (isCallDisabled) {
                showNotification('Звонки отключены. Включите их в настройках.', 'warning');
                return;
            }
            selectedCallType = 'video';
            showCallTypeModal();
        });

        document.querySelectorAll('.call-type-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.call-type-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                this.classList.add('selected');
                selectedCallType = this.dataset.type;
            });
        });

        document.getElementById('startCallWithTypeBtn').addEventListener('click', async () => {
            if (!currentChat || currentChat.isGroup || currentChat.isChannel) {
                showNotification('Звонки доступны только в личных чатах', 'error');
                return;
            }

            document.getElementById('callTypeModal').classList.add('hidden');
            await startCall();
        });

        document.getElementById('cancelCallTypeBtn').addEventListener('click', () => {
            document.getElementById('callTypeModal').classList.add('hidden');
        });

        document.getElementById('acceptCallBtn').addEventListener('click', async () => {
            if (incomingCallData) {
                await answerCall(incomingCallData);
                stopRingtone();
            }
        });

        document.getElementById('rejectCallBtn').addEventListener('click', async () => {
            if (incomingCallData) {
                await rejectCall(incomingCallData);
                stopRingtone();
            }
        });

        document.getElementById('endCallActiveBtnVideo').addEventListener('click', endCall);
        document.getElementById('endCallActiveBtnAudio').addEventListener('click', endCall);

        document.addEventListener('click', async function(e) {
            if (e.target.classList.contains('join-call-message-btn') || 
                e.target.closest('.join-call-message-btn')) {
                const btn = e.target.classList.contains('join-call-message-btn') ? 
                    e.target : e.target.closest('.join-call-message-btn');
                const callId = btn.dataset.callId;
                
                if (callId && !activeCall) {
                    await joinExistingCall(callId);
                }
            }
        });

        document.getElementById('contactOptionsBtn').addEventListener('click', function(e) {
            showContextMenu(e);
        });
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#contextMenu') && !e.target.closest('#contactOptionsBtn')) {
                document.getElementById('contextMenu').classList.add('hidden');
            }
        });

        document.getElementById('viewProfileBtn').addEventListener('click', viewUserProfile);
        document.getElementById('editNicknameBtn').addEventListener('click', editContactNickname);
        document.getElementById('clearChatBtn').addEventListener('click', clearChat);
        document.getElementById('deleteChatBtn').addEventListener('click', deleteChat);

        document.getElementById('allowNotificationsBtn').addEventListener('click', async () => {
            const permission = await Notification.requestPermission();
            
            if (permission === "granted") {
                showPushNotification('Уведомления включены', 'Теперь вы будете получать уведомления о новых сообщениях и звонках');
            }
            
            document.getElementById('notificationPermission').classList.add('hidden');
        });

        document.getElementById('laterNotificationsBtn').addEventListener('click', () => {
            document.getElementById('notificationPermission').classList.add('hidden');
            setTimeout(() => {
                notificationPermissionAsked = false;
            }, 24 * 60 * 60 * 1000);
        });

        document.getElementById('closeImagePreviewBtn').addEventListener('click', () => {
            document.getElementById('imagePreviewModal').classList.add('hidden');
        });

        document.getElementById('closeVideoPreviewBtn').addEventListener('click', () => {
            const video = document.getElementById('previewedVideo');
            video.pause();
            document.getElementById('videoPreviewModal').classList.add('hidden');
        });

        document.getElementById('closeVideoMessagePreviewBtn').addEventListener('click', () => {
            const video = document.getElementById('videoMessagePreview');
            video.pause();
            document.getElementById('videoMessagePreviewModal').classList.add('hidden');
        });

        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.add('hidden');
            }
        });

        // НОВЫЕ ОБРАБОТЧИКИ: поиск сообщений
        const searchInput = document.getElementById('searchMessagesInput');
        searchInput.addEventListener('input', (e) => {
            if (searchTimeout) clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchMessages(e.target.value);
            }, 500);
        });
        document.getElementById('prevSearchBtn').addEventListener('click', prevSearchResult);
        document.getElementById('nextSearchBtn').addEventListener('click', nextSearchResult);

        // Подписка на каналы
        document.getElementById('channelSubscribeBtn')?.addEventListener('click', async () => {
            const channelId = currentChat?.id;
            if (channelId) await subscribeToChannel(channelId);
        });
        document.getElementById('channelUnsubscribeBtn')?.addEventListener('click', async () => {
            const channelId = currentChat?.id;
            if (channelId) await unsubscribeFromChannel(channelId);
        });

        // Управление звонками
        document.getElementById('muteCallBtnVideo').addEventListener('click', toggleMute);
        document.getElementById('muteCallBtnAudio').addEventListener('click', toggleMute);
        document.getElementById('speakerCallBtnVideo').addEventListener('click', toggleSpeaker);
        document.getElementById('speakerCallBtnAudio').addEventListener('click', toggleSpeaker);
        document.getElementById('videoToggleBtn').addEventListener('click', toggleVideo);

        // Ответы на сообщения
        document.getElementById('cancelReplyBtn').addEventListener('click', cancelReply);
        document.getElementById('profileAvatarContainer').addEventListener('click', () => {
            if (currentUser && currentUser.avatar) {
                previewImage(currentUser.avatar, 'Аватарка');
            }
        });
    }

    function toggleMute() {
        if (!localStream) return;
        
        isMuted = !isMuted;
        const audioTracks = localStream.getAudioTracks();
        
        audioTracks.forEach(track => {
            track.enabled = !isMuted;
        });
        
        const muteBtn = document.querySelector('.mute-call-btn');
        if (isMuted) {
            muteBtn.innerHTML = '🔇';
            muteBtn.style.background = 'linear-gradient(135deg, #F44336 0%, #D32F2F 100%)';
        } else {
            muteBtn.innerHTML = '🎤';
            muteBtn.style.background = 'linear-gradient(135deg, #666 0%, #444 100%)';
        }
    }

    function toggleSpeaker() {
        isSpeakerOn = !isSpeakerOn;
        
        const speakerBtn = document.querySelectorAll('.speaker-call-btn');
        speakerBtn.forEach(btn => {
            if (isSpeakerOn) {
                btn.innerHTML = '🔊';
                btn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #388E3C 100%)';
            } else {
                btn.innerHTML = '🔈';
                btn.style.background = 'linear-gradient(135deg, #666 0%, #444 100%)';
            }
        });
        
        showNotification(isSpeakerOn ? 'Включена громкая связь' : 'Выключена громкая связь', 'info');
    }

    function toggleVideo() {
        if (!localStream) return;
        
        isVideoOn = !isVideoOn;
        const videoTracks = localStream.getVideoTracks();
        
        videoTracks.forEach(track => {
            track.enabled = isVideoOn;
        });
        
        const videoBtn = document.getElementById('videoToggleBtn');
        if (isVideoOn) {
            videoBtn.innerHTML = '📹';
            videoBtn.style.background = 'linear-gradient(135deg, #E91E63 0%, #C2185B 100%)';
        } else {
            videoBtn.innerHTML = '🚫';
            videoBtn.style.background = 'linear-gradient(135deg, #F44336 0%, #D32F2F 100%)';
        }
    }

    function showContextMenu(e) {
        const menu = document.getElementById('contextMenu');
        const buttonRect = e.target.getBoundingClientRect();
        const menuHeight = 200;
        const menuWidth = 250;
        
        let top = buttonRect.bottom + 5;
        let left = buttonRect.left;
        
        if (top + menuHeight > window.innerHeight) {
            top = buttonRect.top - menuHeight - 5;
        }
        
        if (left + menuWidth > window.innerWidth) {
            left = window.innerWidth - menuWidth - 10;
        }
        
        menu.style.top = top + 'px';
        menu.style.left = left + 'px';
        menu.classList.remove('hidden');
    }

    async function viewUserProfile() {
        if (!currentChat || !currentChat.otherUser) return;
        
        try {
            showLoading(true);
            
            const userDoc = await getDoc(doc(db, 'users', currentChat.otherUser.id));
            if (userDoc.exists()) {
                const userData = userDoc.data();
                viewedUserProfile = {
                    id: currentChat.otherUser.id,
                    ...userData
                };
                
                const container = document.getElementById('userProfileContent');
                const displayName = getUserDisplayName(viewedUserProfile);
                const lastActive = userData.lastActive ? 
                    (userData.lastActive.toDate ? userData.lastActive.toDate() : new Date(userData.lastActive)) : 
                    new Date(0);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                let statusHTML = '';
                if (diffMinutes < 2) {
                    statusHTML = '<span class="user-status real-online">🟢 online</span>';
                } else if (diffMinutes < 5) {
                    statusHTML = '<span class="user-status recently-active">🟡 был(а) недавно</span>';
                } else {
                    statusHTML = `<span class="user-status real-offline">⚫ был(а) ${formatLastSeen(lastActive)}</span>`;
                }
                
                const userPosts = posts.get(viewedUserProfile.id) || [];
                let postsHTML = '';
                if (userPosts.length > 0) {
                    postsHTML = userPosts.map(p => `
                        <div style="border-bottom: 1px solid rgba(255,255,255,0.1); padding: 10px;">
                            <div style="color: var(--primary);">${p.text}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${formatTime(p.createdAt)}</div>
                        </div>
                    `).join('');
                } else {
                    postsHTML = '<div style="color: var(--text-secondary);">У пользователя пока нет постов</div>';
                }
                
                const avatarStyle = userData.avatar 
                    ? `background-image: url('${userData.avatar}'); background-size: cover; background-position: center;` 
                    : `background: ${userData.avatarColor || getRandomColor()};`;
                
                container.innerHTML = `
                    <div class="profile-header">
                        <div class="profile-avatar-container">
                            <div class="profile-avatar" style="${avatarStyle}">
                                ${userData.avatar ? '' : (userData.name || '?').charAt(0).toUpperCase()}
                            </div>
                        </div>
                        <div class="profile-name">${displayName}</div>
                        <div class="profile-username">@${userData.username}</div>
                        <div class="profile-status">
                            ${statusHTML}
                        </div>
                    </div>
                    
                    <div class="info-section">
                        <h3>Информация</h3>
                        <div class="info-item">
                            <div class="info-label">Имя</div>
                            <div class="info-value">${userData.name || 'Не указано'}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Никнейм</div>
                            <div class="info-value">@${userData.username}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">ID пользователя</div>
                            <div class="info-value">${viewedUserProfile.id.substring(0, 8)}...</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Дата регистрации</div>
                            <div class="info-value">${formatDate(userData.createdAt)}</div>
                        </div>
                    </div>

                    <div class="info-section">
                        <h3>📝 История</h3>
                        <div id="userPostsList">${postsHTML}</div>
                    </div>
                    
                    <button class="btn" style="width: 100%; margin-top: 20px;" id="changeNicknameBtn">
                        ✏️ Изменить имя для себя
                    </button>
                `;
                
                document.getElementById('changeNicknameBtn').addEventListener('click', () => {
                    editContactNickname();
                });
                
                showScreen('userProfileScreen');
            }
        } catch (error) {
            console.error('Ошибка загрузки профиля:', error);
            showNotification('Ошибка загрузки профиля', 'error');
        } finally {
            showLoading(false);
        }
    }

    function editContactNickname() {
        if (!currentChat || !currentChat.otherUser) return;
        
        document.getElementById('contextMenu').classList.add('hidden');
        
        const currentNickname = getUserDisplayName(currentChat.otherUser);
        const newNickname = prompt('Введите новое имя для этого контакта (только для вас):', currentNickname);
        
        if (newNickname === null) return;
        
        if (newNickname.trim() === '') {
            saveUserNickname(currentChat.otherUser.id, null);
            showNotification('Имя удалено, будет отображаться оригинальное имя', 'info');
        } else {
            saveUserNickname(currentChat.otherUser.id, newNickname.trim());
            showNotification('Имя изменено', 'success');
        }
        
        if (currentChat) {
            document.getElementById('chatTitle').textContent = getUserDisplayName(currentChat.otherUser);
        }
        
        if (viewedUserProfile) {
            viewUserProfile();
        }
        
        loadChats();
    }

    async function clearChat() {
        document.getElementById('contextMenu').classList.add('hidden');
        
        if (!currentChat || !confirm('Очистить историю чата? Это действие нельзя отменить.')) return;
        
        try {
            showLoading(true);
            
            const messagesQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', currentChat.id)
            );
            
            const snapshot = await getDocs(messagesQuery);
            const deletePromises = [];
            
            snapshot.forEach(doc => {
                deletePromises.push(deleteDoc(doc.ref));
            });
            
            await Promise.all(deletePromises);
            
            await updateDoc(doc(db, 'chats', currentChat.id), {
                lastMessage: 'Чат очищен',
                updatedAt: serverTimestamp()
            });
            
            showNotification('Чат очищен', 'success');
            
            loadMessages(currentChat.id);
            
        } catch (error) {
            console.error('Ошибка очистки чата:', error);
            showNotification('Ошибка очистки чата', 'error');
        } finally {
            showLoading(false);
        }
    }

    async function deleteChat() {
        document.getElementById('contextMenu').classList.add('hidden');
        
        if (!currentChat || !confirm('Удалить чат? Это действие нельзя отменить.')) return;
        
        try {
            showLoading(true);
            
            const messagesQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', currentChat.id)
            );
            
            const snapshot = await getDocs(messagesQuery);
            const deletePromises = [];
            
            snapshot.forEach(doc => {
                deletePromises.push(deleteDoc(doc.ref));
            });
            
            deletePromises.push(deleteDoc(doc(db, 'chats', currentChat.id)));
            
            await Promise.all(deletePromises);
            
            showNotification('Чат удален', 'success');
            
            backToChats();
            loadChats();
            
        } catch (error) {
            console.error('Ошибка удаления чата:', error);
            showNotification('Ошибка удаления чата', 'error');
        } finally {
            showLoading(false);
        }
    }

    async function joinExistingCall(callId) {
        if (!callId) {
            showNotification('Неверный ID звонка', 'error');
            return;
        }
        
        if (activeCall) {
            showNotification('У вас уже есть активный звонок', 'warning');
            return;
        }
        
        try {
            showLoading(true);
            
            const callsQuery = query(
                collection(db, 'messages'),
                where('callId', '==', callId),
                where('type', '==', 'call'),
                limit(1)
            );
            
            const snapshot = await getDocs(callsQuery);
            if (snapshot.empty) {
                throw new Error('Звонок не найден');
            }
            
            const callDoc = snapshot.docs[0];
            const callData = { id: callDoc.id, ...callDoc.data() };
            
            if (!callData.callActive) {
                throw new Error('Этот звонок уже завершен');
            }
            
            if (callData.senderId === currentUser.id) {
                showNotification('Это ваш собственный звонок', 'info');
                return;
            }
            
            const constraints = callData.callType === 'video' 
                ? { audio: true, video: true } 
                : { audio: true };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            if (callData.callType === 'video') {
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                document.getElementById('videoContainer').style.display = 'block';
                document.getElementById('audioCallContainer').style.display = 'none';
            } else {
                document.getElementById('videoContainer').style.display = 'none';
                document.getElementById('audioCallContainer').style.display = 'block';
            }
            
            currentCallId = callId;
            
            activeCall = {
                id: callId,
                chatId: callData.chatId,
                userId: callData.senderId,
                userName: callData.senderName,
                isIncoming: true,
                callType: callData.callType,
                startTime: new Date(),
                messageId: callData.id,
                stream: localStream
            };
            
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    { urls: 'stun:stun.ekiga.net' },
                    { urls: 'stun:stun.ideasip.com' },
                    { urls: 'stun:stun.schlund.de' },
                    { urls: 'stun:stun.stunprotocol.org:3478' },
                    { urls: 'stun:stun.voiparound.com' },
                    { urls: 'stun:stun.voipbuster.com' },
                    { urls: 'stun:stun.voipstunt.com' },
                    { urls: 'stun:stun.voxgratia.org' },
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                iceTransportPolicy: 'all',
                iceCandidatePoolSize: 10,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            
            setupPeerConnection(configuration, false);
            
            showActiveCallScreen(activeCall);
            startCallTimer();
            
            await updateDoc(doc(db, 'messages', callData.id), {
                answered: true,
                answeredAt: serverTimestamp(),
                callActive: true
            });
            
            showNotification('Вы присоединились к звонку', 'success');
            
        } catch (error) {
            console.error('Ошибка присоединения к звонку:', error);
            showNotification('Ошибка присоединения к звонку: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    async function getUserById(userId) {
        try {
            const userDoc = await getDoc(doc(db, 'users', userId));
            if (userDoc.exists()) {
                return { id: userId, ...userDoc.data() };
            }
        } catch (error) {
            console.error('Ошибка получения пользователя:', error);
        }
        return { id: userId, name: 'Неизвестный' };
    }

    function switchTab(tabType) {
        document.querySelectorAll('.modal-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`.modal-tab[data-tab="${tabType}"]`).classList.add('active');

        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tabType + 'Tab').classList.add('active');

        if (tabType === 'group') {
            groupMembers.clear();
            updateGroupMembersList();
        }
    }

    async function loadAllUsersForSearch() {
        if (!currentUser) return;
        
        try {
            console.log("📥 Загружаем всех пользователей для поиска...");
            const usersRef = collection(db, 'users');
            const snapshot = await getDocs(usersRef);
            
            allUsersCache.clear();
            snapshot.forEach(doc => {
                if (doc.id !== currentUser.id) {
                    const userData = doc.data();
                    allUsersCache.set(doc.id, {
                        id: doc.id,
                        ...userData
                    });
                    
                    allUsers.set(doc.id, {
                        id: doc.id,
                        ...userData
                    });
                }
            });
            
            console.log("✅ Загружено пользователей для поиска:", allUsersCache.size);
        } catch (error) {
            console.error('❌ Ошибка загрузки всех пользователей:', error);
        }
    }

    function showRegister() {
        document.getElementById('loginForm').classList.add('hidden');
        document.getElementById('registerForm').classList.remove('hidden');
    }

    function showLogin() {
        document.getElementById('registerForm').classList.add('hidden');
        document.getElementById('loginForm').classList.remove('hidden');
    }

    async function login() {
        const username = document.getElementById('loginUsername').value.trim().toLowerCase();
        const password = document.getElementById('loginPassword').value;
        
        if (!username || !password) {
            showNotification('Заполните все поля', 'error');
            return;
        }

        const btn = document.getElementById('loginBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<div class="loading"></div>';
        btn.disabled = true;

        try {
            if (authError) {
                const localUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
                const user = localUsers.find(u => u.username === username);
                
                if (user && user.password === password) {
                    currentUser = user;
                    localStorage.setItem('absgram_user_local', JSON.stringify(user));
                    showScreen('chatsScreen');
                    await loadChats();
                    loadAllNicknames();
                } else {
                    throw new Error('Неверный логин или пароль');
                }
            } else {
                console.log("🔑 Пробуем войти:", username);
                
                const usersQuery = query(collection(db, 'users'), where('username', '==', username));
                const querySnapshot = await getDocs(usersQuery);
                
                if (querySnapshot.empty) {
                    throw new Error('Пользователь не найден');
                }
                
                const userDoc = querySnapshot.docs[0];
                const userData = userDoc.data();
                const userEmail = userData.email;
                
                await signInWithEmailAndPassword(auth, userEmail, password);
                console.log("✅ Вход выполнен");
                
                localStorage.setItem('absgram_user', JSON.stringify({
                    username: username,
                    timestamp: Date.now()
                }));
            }
            
        } catch (error) {
            console.error('❌ Ошибка входа:', error);
            let message = 'Ошибка входа';
            if (error.message.includes('не найден') || error.message.includes('Неверный')) {
                message = 'Неверный логин или пароль';
            }
            showNotification(message, 'error');
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    async function register() {
        const name = document.getElementById('registerName').value.trim();
        const username = document.getElementById('registerUsername').value.trim().toLowerCase();
        const password = document.getElementById('registerPassword').value;
        
        if (!name || !username || !password) {
            showNotification('Заполните все поля', 'error');
            return;
        }

        if (password.length < 6) {
            showNotification('Пароль должен быть не менее 6 символов', 'error');
            return;
        }

        if (!/^[a-z0-9_]+$/.test(username)) {
            showNotification('Никнейм может содержать только латинские буквы, цифры и нижнее подчеркивание', 'error');
            return;
        }

        const btn = document.getElementById('registerBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<div class="loading"></div>';
        btn.disabled = true;

        try {
            if (authError) {
                const localUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
                
                if (localUsers.some(u => u.username === username)) {
                    throw new Error('Этот никнейм уже занят');
                }
                
                const newUser = {
                    id: 'user_' + Date.now(),
                    name: name,
                    username: username,
                    password: password,
                    avatarColor: getRandomColor(),
                    createdAt: new Date().toISOString()
                };
                
                localUsers.push(newUser);
                localStorage.setItem('absgram_all_users', JSON.stringify(localUsers));
                
                currentUser = newUser;
                localStorage.setItem('absgram_user_local', JSON.stringify(newUser));
                
                showScreen('chatsScreen');
                
                await loadChats();
                loadAllNicknames();
                loadCallsDisabledState();
                
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                return;
            }
            
            console.log("🚀 Начинаем регистрацию пользователя:", username);
            
            const usersQuery = query(collection(db, 'users'), where('username', '==', username));
            const querySnapshot = await getDocs(usersQuery);
            
            if (!querySnapshot.empty) {
                throw new Error('Этот никнейм уже занят');
            }
            
            const email = `${username}@absgram.com`;
            
            console.log("🔐 Создаем пользователя в Firebase Auth...");
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;
            console.log("✅ Пользователь создан в Auth:", user.uid);
            
            if (!auth.currentUser || auth.currentUser.uid !== user.uid) {
                console.log("🔄 Пользователь не аутентифицирован, пробуем войти...");
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (loginError) {
                    console.log("⚠️ Ошибка автоматического входа, продолжаем:", loginError);
                }
            }
            
            console.log("💾 Создаем документ в Firestore...");
            const userData = {
                name: name,
                username: username,
                email: email,
                avatar: null,
                avatarColor: getRandomColor(),
                isOnline: true,
                lastActive: serverTimestamp(),
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                searchName: name.toLowerCase(),
                searchUsername: username.toLowerCase()
            };
            
            console.log("📝 Данные для сохранения:", userData);
            
            if (!auth.currentUser) {
                console.log("⚠️ Пользователь не аутентифицирован, создаем документ с UID:", user.uid);
                await setDoc(doc(db, 'users', user.uid), userData);
            } else {
                await setDoc(doc(db, 'users', auth.currentUser.uid), userData);
            }
            
            console.log("✅ Документ пользователя создан в Firestore");
            
            btn.innerHTML = originalText;
            btn.disabled = false;
            
        } catch (error) {
            console.error('❌ Ошибка регистрации:', error);
            
            let message = 'Ошибка регистрации';
            
            if (error.message.includes('уже занят')) {
                message = 'Этот никнейм уже занят';
            } else if (error.code === 'auth/weak-password') {
                message = 'Пароль слишком слабый. Используйте не менее 6 символов.';
            } else if (error.code === 'auth/email-already-in-use') {
                message = 'Этот email уже используется';
            } else if (error.code === 'permission-denied') {
                message = 'Ошибка доступа к Firestore. Работаем в локальном режиме.';
                authError = true;
                await register();
            } else if (error.message.includes('не аутентифицирован')) {
                message = 'Ошибка аутентификации. Попробуйте еще раз.';
            } else {
                message = `Ошибка: ${error.message}`;
            }
            
            showNotification(message, 'error');
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    async function loadUserData(userId) {
        try {
            console.log("📥 Загружаем данные пользователя из Firestore:", userId);
            
            const userDoc = await getDoc(doc(db, 'users', userId));
            
            if (userDoc.exists()) {
                const userData = userDoc.data();
                currentUser = {
                    id: userId,
                    ...userData
                };
                
                const lastActive = userData.lastActive ? 
                    (userData.lastActive.toDate ? userData.lastActive.toDate() : new Date(userData.lastActive)) : 
                    new Date(0);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                currentUser.realIsOnline = diffMinutes < 2;
                
                console.log("✅ Данные пользователя загружены:", currentUser);
                updateProfile();
                
                try {
                    await updateDoc(doc(db, 'users', userId), {
                        isOnline: true,
                        lastActive: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Ошибка обновления статуса онлайн:', error);
                }
            } else {
                console.error("❌ Документ пользователя не найден в Firestore!");
                showNotification('Ошибка загрузки данных пользователя', 'error');
                await signOut(auth);
            }
        } catch (error) {
            console.error('❌ Ошибка загрузки данных пользователя:', error);
            showNotification('Ошибка загрузки данных пользователя', 'error');
        }
    }

    function updateProfile() {
        if (!currentUser) return;
        
        console.log("👤 Обновляем профиль:", currentUser.name);
        document.getElementById('profileName').textContent = currentUser.name;
        document.getElementById('profileUsername').textContent = '@' + currentUser.username;
        document.getElementById('profileUsernameValue').textContent = '@' + currentUser.username;
        document.getElementById('profileId').textContent = currentUser.id.substring(0, 8) + '...';
        document.getElementById('profileDate').textContent = formatDate(currentUser.createdAt);
        
        const avatar = document.getElementById('profileAvatar');
        if (currentUser.avatar) {
            avatar.style.backgroundImage = `url('${currentUser.avatar}')`;
            avatar.style.backgroundSize = 'cover';
            avatar.style.backgroundPosition = 'center';
            avatar.textContent = '';
            avatar.style.backgroundColor = '';
        } else {
            avatar.style.backgroundImage = '';
            avatar.textContent = currentUser.name.charAt(0).toUpperCase();
            avatar.style.backgroundColor = currentUser.avatarColor || getRandomColor();
        }

        const userPosts = posts.get(currentUser.id) || [];
        const postsContainer = document.getElementById('profilePostsList');
        if (userPosts.length > 0) {
            postsContainer.innerHTML = userPosts.map(p => `
                <div style="border-bottom: 1px solid rgba(255,255,255,0.1); padding: 10px; width: 100%;">
                    <div style="color: var(--primary);">${p.text}</div>
                    <div style="font-size: 11px; color: var(--text-secondary);">${formatTime(p.createdAt)}</div>
                </div>
            `).join('');
        } else {
            postsContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; width: 100%;">У вас пока нет постов</div>';
        }
        
        loadUserChatsCount();
    }

    async function loadUserChatsCount() {
        if (!currentUser) return;
        
        try {
            const chatsQuery = query(
                collection(db, 'chats'),
                where('participants', 'array-contains', currentUser.id)
            );
            const chatsSnapshot = await getDocs(chatsQuery);
            document.getElementById('profileChatsCount').textContent = chatsSnapshot.size;
        } catch (error) {
            console.error('❌ Ошибка загрузки количества чатов:', error);
            document.getElementById('profileChatsCount').textContent = '0';
        }
    }

    async function editName() {
        const newName = prompt('Введите новое имя:', currentUser.name);
        if (!newName || newName.trim() === '' || newName === currentUser.name) return;
        
        const name = newName.trim();
        
        showLoading(true);
        try {
            if (!authError) {
                await updateDoc(doc(db, 'users', currentUser.id), {
                    name: name,
                    searchName: name.toLowerCase(),
                    updatedAt: serverTimestamp()
                });
            }
            
            currentUser.name = name;
            currentUser.searchName = name.toLowerCase();
            
            if (authError) {
                localStorage.setItem('absgram_user_local', JSON.stringify(currentUser));
            }
            
            updateProfile();
            loadChats();
            
        } catch (error) {
            console.error('Ошибка изменения имени:', error);
            showNotification('Ошибка изменения имени', 'error');
        } finally {
            showLoading(false);
        }
    }

    function logout() {
        if (confirm('Вы уверены, что хотите выйти?')) {
            if (currentUser && !authError) {
                try {
                    updateDoc(doc(db, 'users', currentUser.id), {
                        isOnline: false,
                        lastActive: serverTimestamp()
                    }).catch(console.error);
                } catch (error) {
                    console.error('Ошибка обновления статуса при выходе:', error);
                }
            }
            
            if (unsubscribeChats) unsubscribeChats();
            if (unsubscribeMessages) unsubscribeMessages();
            if (callListeners.size > 0) {
                callListeners.forEach(unsubscribe => unsubscribe());
                callListeners.clear();
            }
            if (onlineStatusInterval) {
                clearInterval(onlineStatusInterval);
                onlineStatusInterval = null;
            }
            if (typingListeners.size > 0) {
                typingListeners.forEach(unsubscribe => unsubscribe());
                typingListeners.clear();
            }
            if (callRingingListeners.size > 0) {
                callRingingListeners.forEach(unsubscribe => unsubscribe());
                callRingingListeners.clear();
            }
            
            signOut(auth).then(() => {
                currentUser = null;
                currentChat = null;
                allUsers.clear();
                allUsersCache.clear();
                userNicknames.clear();
                authError = false;
                localStorage.removeItem('absgram_user_local');
                localStorage.removeItem('absgram_user');
                showScreen('authScreen');
            }).catch(error => {
                console.error('Ошибка выхода:', error);
                showNotification('Ошибка выхода', 'error');
            });
        }
    }

    function backToChats() {
        if (unsubscribeMessages) {
            unsubscribeMessages();
            unsubscribeMessages = null;
        }
        
        if (typingListeners.has('current')) {
            clearTimeout(typingListeners.get('current'));
            typingListeners.delete('current');
        }
        
        document.getElementById('messageInput').value = '';
        document.getElementById('messageInput').style.height = 'auto';
        document.getElementById('sendMessageBtn').disabled = true;
        showScreen('chatsScreen');
        
        updateUnreadCounts();
    }

    function showProfile() {
        updateProfile();
        showScreen('profileScreen');
    }

    function showNewChatModal() {
        groupMembers.clear();
        updateGroupMembersList();
        
        document.getElementById('newChatModal').classList.remove('hidden');
        switchTab('single');
        
        document.getElementById('singleSearchInput').focus();
    }

    function closeGroupModal() {
        document.getElementById('newChatModal').classList.add('hidden');
        document.getElementById('groupName').value = '';
        document.getElementById('channelName').value = '';
        document.getElementById('channelDescription').value = '';
        document.getElementById('groupSearchInput').value = '';
        document.getElementById('singleSearchInput').value = '';
        groupMembers.clear();
        document.getElementById('singleSearchResults').innerHTML = '';
        document.getElementById('groupSearchResults').innerHTML = '';
    }

    async function searchUsersAndChannels(searchQuery) {
        if (!currentUser || !searchQuery.trim()) {
            const searchHint = document.querySelector('.search-hint');
            if (searchHint) searchHint.style.display = 'block';
            return;
        }
        
        console.log("🔍 Поиск пользователей и каналов:", searchQuery);
        const searchHint = document.querySelector('.search-hint');
        if (searchHint) searchHint.style.display = 'none';

        if (searchQuery.startsWith('https://') || searchQuery.startsWith('absgram://')) {
            const parts = searchQuery.split('/');
            const channelId = parts[parts.length - 1];
            if (channelId) {
                try {
                    const chatRef = doc(db, 'chats', channelId);
                    const chatSnap = await getDoc(chatRef);
                    if (chatSnap.exists() && chatSnap.data().isChannel) {
                        const chatData = chatSnap.data();
                        const isSubscribed = chatData.participants && chatData.participants.includes(currentUser.id);
                        
                        if (!isSubscribed && chatData.channelType === 'private') {
                            await subscribeToChannel(channelId);
                        }
                        
                        openChat({ id: channelId, ...chatData });
                        return;
                    }
                } catch (e) {
                    console.log('Не удалось найти канал по ссылке');
                }
            }
        }
        
        if (authError) {
            const localUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
            const users = localUsers.filter(user => {
                const query = searchQuery.toLowerCase();
                const userName = user.name ? user.name.toLowerCase() : '';
                const userUsername = user.username ? user.username.toLowerCase() : '';
                
                return userName.includes(query) || 
                       userUsername.includes(query);
            });
            
            renderSearchResults(users);
            return;
        }
        
        const users = Array.from(allUsersCache.values()).filter(user => {
            const query = searchQuery.toLowerCase();
            const userName = user.name ? user.name.toLowerCase() : '';
            const userUsername = user.username ? user.username.toLowerCase() : '';
            
            return userName.includes(query) || 
                   userUsername.includes(query);
        });
        
        try {
            const channelsQuery = query(
                collection(db, 'chats'),
                where('isChannel', '==', true),
                where('channelType', '==', 'public'),
                orderBy('channelName')
            );
            const channelsSnapshot = await getDocs(channelsQuery);
            channelsSnapshot.forEach(doc => {
                const channelData = doc.data();
                if (channelData.channelName && channelData.channelName.toLowerCase().includes(searchQuery.toLowerCase())) {
                    users.push({
                        id: doc.id,
                        name: channelData.channelName,
                        username: channelData.channelName,
                        isChannel: true,
                        channelDesc: channelData.channelDesc,
                        avatarColor: getRandomColor(),
                        participantIds: channelData.participants || [channelData.channelOwner]
                    });
                }
            });
        } catch (e) {
            console.warn('Ошибка поиска каналов:', e);
        }
        
        if (users.length > 0) {
            console.log("✅ Найдено:", users.length);
            renderSearchResults(users);
            return;
        } else {
            console.log("❌ Ничего не найдено");
            renderSearchResults([]);
        }
    }

    async function searchUsersForChat(query, type) {
        if (!query.trim()) {
            if (type === 'single') {
                document.getElementById('singleSearchResults').innerHTML = '';
            } else {
                document.getElementById('groupSearchResults').innerHTML = '';
            }
            return;
        }
        
        if (authError) {
            const localUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
            const users = localUsers.filter(user => {
                const searchQuery = query.toLowerCase();
                const userName = user.name ? user.name.toLowerCase() : '';
                const userUsername = user.username ? user.username.toLowerCase() : '';
                
                return userName.includes(searchQuery) || 
                       userUsername.includes(searchQuery);
            });
            
            if (type === 'single') {
                renderSingleChatResults(users);
            } else {
                renderGroupChatResults(users);
            }
            return;
        }
        
        const users = Array.from(allUsersCache.values()).filter(user => {
            const searchQuery = query.toLowerCase();
            const userName = user.name ? user.name.toLowerCase() : '';
            const userUsername = user.username ? user.username.toLowerCase() : '';
            
            return userName.includes(searchQuery) || 
                   userUsername.includes(searchQuery);
        });
        
        if (type === 'single') {
            renderSingleChatResults(users);
        } else {
            renderGroupChatResults(users);
        }
    }

    function renderSearchResults(users) {
        const container = document.getElementById('chatsList');
        
        if (users.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="icon">👤</div>
                    <p>Пользователи или каналы не найдены</p>
                    <p style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                        Попробуйте изменить запрос или проверьте написание
                    </p>
                    <p style="font-size: 12px; margin-top: 5px; color: var(--text-secondary);">
                        🔍 Можно искать по имени, никнейму или ссылке
                    </p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = '';
        
        users.sort((a, b) => {
            if (a.realIsOnline && !b.realIsOnline) return -1;
            if (!a.realIsOnline && b.realIsOnline) return 1;
            
            return a.name.localeCompare(b.name);
        });
        
        users.forEach(user => {
            const div = document.createElement('div');
            div.className = 'user-item';
            if (user.isChannel) {
                div.onclick = () => joinChannelById(user.id);
            } else {
                div.onclick = () => createChatWithUser(user);
            }
            
            const displayName = user.isChannel ? `📢 ${user.name}` : getUserDisplayName(user);
            const query = document.getElementById('searchUsersInput').value.trim().toLowerCase();
            let finalDisplayName = displayName;
            
            if (query && displayName.toLowerCase().includes(query)) {
                const regex = new RegExp(`(${query})`, 'gi');
                finalDisplayName = displayName.replace(regex, '<mark style="background: rgba(255,107,53,0.3); color: var(--primary); font-weight: bold; padding: 2px 0; border-radius: 3px;">$1</mark>');
            }
            
            let statusHTML = '';
            if (user.isChannel) {
                statusHTML = '<span class="user-status real-online">📢 Канал</span>';
            } else if (user.realIsOnline === true) {
                statusHTML = '<span class="user-status real-online">🟢 online</span>';
            } else if (user.lastActive) {
                const lastActive = user.lastActive.toDate ? user.lastActive.toDate() : new Date(user.lastActive);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                if (diffMinutes < 5) {
                    statusHTML = '<span class="user-status recently-active">🟡 был(а) недавно</span>';
                } else {
                    statusHTML = `<span class="user-status real-offline">⚫ был(а) ${formatLastSeen(lastActive)}</span>`;
                }
            } else {
                statusHTML = '<span class="user-status real-offline">⚫ не в сети</span>';
            }
            
            div.innerHTML = `
                <div class="user-avatar" style="background: ${user.isChannel ? getRandomColor() : user.avatarColor || getRandomColor()}; 
                     ${user.avatar ? `background-image: url('${user.avatar}'); background-size: cover; background-position: center;` : ''}">
                    ${user.isChannel ? '📢' : (user.avatar ? '' : user.name.charAt(0).toUpperCase())}
                </div>
                <div class="user-info">
                    <div class="user-name">${finalDisplayName}</div>
                    <div class="user-username">${user.isChannel ? '' : '@' + user.username}</div>
                    <div class="user-status">
                        ${statusHTML}
                    </div>
                </div>
            `;
            
            container.appendChild(div);
        });
        
        const onlineCount = users.filter(u => u.realIsOnline === true).length;
        const stats = document.createElement('div');
        stats.className = 'search-hint';
        stats.innerHTML = `Найдено: ${users.length} элементов (${onlineCount} онлайн)`;
        container.appendChild(stats);
    }

    function renderSingleChatResults(users) {
        const container = document.getElementById('singleSearchResults');
        container.innerHTML = '';
        
        if (users.length === 0) {
            container.innerHTML = `
                <div class="empty-state" style="height: 200px;">
                    <div class="icon">👤</div>
                    <p>Пользователи не найдены</p>
                </div>
            `;
            return;
        }
        
        users.forEach(user => {
            const div = document.createElement('div');
            div.className = 'user-item';
            div.onclick = () => createChatWithUser(user);
            
            const displayName = getUserDisplayName(user);
            
            let statusHTML = '';
            if (user.realIsOnline === true) {
                statusHTML = '<span class="user-status real-online">🟢 online</span>';
            } else if (user.lastActive) {
                const lastActive = user.lastActive.toDate ? user.lastActive.toDate() : new Date(user.lastActive);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                if (diffMinutes < 5) {
                    statusHTML = '<span class="user-status recently-active">🟡 был(а) недавно</span>';
                } else {
                    statusHTML = `<span class="user-status real-offline">⚫ был(а) ${formatLastSeen(lastActive)}</span>`;
                }
            } else {
                statusHTML = '<span class="user-status real-offline">⚫ не в сети</span>';
            }
            
            div.innerHTML = `
                <div class="user-avatar" style="background: ${user.avatarColor || getRandomColor()}; 
                     ${user.avatar ? `background-image: url('${user.avatar}'); background-size: cover; background-position: center;` : ''}">
                    ${user.avatar ? '' : user.name.charAt(0).toUpperCase()}
                </div>
                <div class="user-info">
                    <div class="user-name">${displayName}</div>
                    <div class="user-username">@${user.username}</div>
                    <div class="user-status">
                        ${statusHTML}
                    </div>
                </div>
            `;
            
            container.appendChild(div);
        });
    }

    function renderGroupChatResults(users) {
        const container = document.getElementById('groupSearchResults');
        container.innerHTML = '';
        
        if (users.length === 0) {
            container.innerHTML = `
                <div class="empty-state" style="height: 150px;">
                    <div class="icon">👤</div>
                    <p>Пользователи не найдены</p>
                </div>
            `;
            return;
        }
        
        users.forEach(user => {
            if (groupMembers.has(user.id) || user.id === currentUser.id) return;
            
            const div = document.createElement('div');
            div.className = 'user-item';
            div.onclick = () => addToGroup(user);
            
            const displayName = getUserDisplayName(user);
            
            let statusHTML = '';
            if (user.realIsOnline === true) {
                statusHTML = '<span class="user-status real-online">🟢 online</span>';
            } else if (user.lastActive) {
                const lastActive = user.lastActive.toDate ? user.lastActive.toDate() : new Date(user.lastActive);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                if (diffMinutes < 5) {
                    statusHTML = '<span class="user-status recently-active">🟡 был(а) недавно</span>';
                } else {
                    statusHTML = `<span class="user-status real-offline">⚫ был(а) ${formatLastSeen(lastActive)}</span>`;
                }
            } else {
                statusHTML = '<span class="user-status real-offline">⚫ не в сети</span>';
            }
            
            div.innerHTML = `
                <div class="user-avatar" style="background: ${user.avatarColor || getRandomColor()}; 
                     ${user.avatar ? `background-image: url('${user.avatar}'); background-size: cover; background-position: center;` : ''}">
                    ${user.avatar ? '' : user.name.charAt(0).toUpperCase()}
                </div>
                <div class="user-info">
                    <div class="user-name">${displayName}</div>
                    <div class="user-username">@${user.username}</div>
                    <div class="user-status">
                        ${statusHTML}
                    </div>
                </div>
            `;
            
            container.appendChild(div);
        });
    }

    async function joinChannelById(channelId) {
        try {
            const chatDoc = await getDoc(doc(db, 'chats', channelId));
            if (chatDoc.exists() && chatDoc.data().isChannel) {
                const chatData = chatDoc.data();
                const isSubscribed = chatData.participants && chatData.participants.includes(currentUser.id);
                
                if (!isSubscribed && chatData.channelType === 'public') {
                    await subscribeToChannel(channelId);
                }
                
                openChat({ id: channelId, ...chatData });
            } else {
                showNotification('Канал не найден', 'error');
            }
        } catch (error) {
            console.error('Ошибка присоединения к каналу:', error);
            showNotification('Ошибка присоединения к каналу', 'error');
        }
    }

    async function createChatWithUser(user) {
        if (!currentUser) return;
        
        showLoading(true);
        try {
            if (authError) {
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const existingChat = chats.find(chat => 
                    !chat.isGroup && !chat.isChannel &&
                    chat.participants && 
                    chat.participants.includes(user.id) && 
                    chat.participants.includes(currentUser.id)
                );
                
                if (existingChat) {
                    openChat({
                        ...existingChat,
                        otherUser: user
                    });
                    showScreen('chatScreen');
                } else {
                    const chatId = 'chat_' + Date.now();
                    const chat = {
                        id: chatId,
                        participants: [currentUser.id, user.id],
                        isGroup: false,
                        isChannel: false,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        lastMessage: '',
                        unreadCount: 0,
                        otherUser: user
                    };
                    
                    chats.push(chat);
                    localStorage.setItem('absgram_chats', JSON.stringify(chats));
                    
                    openChat(chat);
                    
                    showScreen('chatScreen');
                }
                
                closeGroupModal();
                showLoading(false);
                return;
            }
            
            const chatsQuery = query(
                collection(db, 'chats'),
                where('participants', 'array-contains', currentUser.id)
            );
            
            const existingChats = await getDocs(chatsQuery);
            let existingChatId = null;
            
            existingChats.forEach(doc => {
                const chat = doc.data();
                if (chat.participants && chat.participants.includes(user.id) && !chat.isGroup && !chat.isChannel) {
                    existingChatId = doc.id;
                }
            });
            
            if (existingChatId) {
                const chatDoc = await getDoc(doc(db, 'chats', existingChatId));
                openChat({
                    id: existingChatId,
                    ...chatDoc.data(),
                    otherUser: user
                });
                showScreen('chatScreen');
            } else {
                const chatData = {
                    participants: [currentUser.id, user.id],
                    isGroup: false,
                    isChannel: false,
                    groupName: null,
                    groupAdmin: null,
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp(),
                    lastMessage: '',
                    unreadCount: 0
                };
                
                const chatRef = await addDoc(collection(db, 'chats'), chatData);
                
                openChat({
                    id: chatRef.id,
                    ...chatData,
                    otherUser: user
                });
                
                showScreen('chatScreen');
            }
            
            closeGroupModal();
            
        } catch (error) {
            console.error('Ошибка создания чата:', error);
            showNotification('Ошибка создания чата', 'error');
        } finally {
            showLoading(false);
        }
    }

    function showAvatarModal() {
        selectedAvatar = currentUser.avatar;
        selectedAvatarColor = currentUser.avatarColor;
        
        const preview = document.getElementById('avatarPreview');
        if (selectedAvatar) {
            preview.style.backgroundImage = `url('${selectedAvatar}')`;
            preview.style.backgroundSize = 'cover';
            preview.style.backgroundPosition = 'center';
            preview.textContent = '';
            preview.style.backgroundColor = '';
        } else {
            preview.style.backgroundImage = '';
            preview.textContent = currentUser.name.charAt(0).toUpperCase();
            preview.style.backgroundColor = selectedAvatarColor || getRandomColor();
        }
        
        document.getElementById('avatarModal').classList.remove('hidden');
    }

    function closeAvatarModal() {
        document.getElementById('avatarModal').classList.add('hidden');
        selectedAvatar = null;
        selectedAvatarColor = null;
        document.getElementById('avatarUpload').value = '';
    }

    function selectAvatar(color) {
        selectedAvatar = null;
        selectedAvatarColor = color;
        
        const preview = document.getElementById('avatarPreview');
        preview.style.backgroundImage = '';
        preview.textContent = currentUser.name.charAt(0).toUpperCase();
        preview.style.backgroundColor = color;
        
        document.querySelectorAll('.avatar-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        event.target.classList.add('selected');
    }

    function handleAvatarUpload(file) {
        if (!file) return;
        
        if (!file.type.match('image/(jpeg|jpg|png|gif|webp)')) {
            showNotification('Разрешены только изображения', 'error');
            return;
        }
        
        if (file.size > 10 * 1024 * 1024) {
            showNotification('Файл должен быть меньше 10MB', 'error');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(event) {
            selectedAvatar = event.target.result;
            selectedAvatarColor = null;
            
            const preview = document.getElementById('avatarPreview');
            preview.style.backgroundImage = `url('${selectedAvatar}')`;
            preview.style.backgroundSize = 'cover';
            preview.style.backgroundPosition = 'center';
            preview.textContent = '';
            preview.style.backgroundColor = '';
        };
        reader.readAsDataURL(file);
    }

    async function saveAvatar() {
        if (!selectedAvatar && !selectedAvatarColor) {
            showNotification('Ничего не выбрано', 'error');
            return;
        }

        showLoading(true);
        try {
            if (!authError) {
                await updateDoc(doc(db, 'users', currentUser.id), {
                    avatar: selectedAvatar || null,
                    avatarColor: selectedAvatarColor || null,
                    updatedAt: serverTimestamp()
                });
            }
            
            currentUser.avatar = selectedAvatar;
            currentUser.avatarColor = selectedAvatarColor;
            
            if (authError) {
                localStorage.setItem('absgram_user_local', JSON.stringify(currentUser));
            }
            
            updateProfile();
            closeAvatarModal();
        } catch (error) {
            console.error('Ошибка сохранения аватарки:', error);
            showNotification('Ошибка сохранения аватарки', 'error');
        } finally {
            showLoading(false);
        }
    }

    function addToGroup(user) {
        if (!groupMembers.has(user.id)) {
            groupMembers.set(user.id, user);
            updateGroupMembersList();
        }
    }

    window.removeFromGroup = function(userId) {
        groupMembers.delete(userId);
        updateGroupMembersList();
    };

    function updateGroupMembersList() {
        const container = document.getElementById('groupMembersList');
        const memberCount = document.getElementById('memberCount');
        
        container.innerHTML = '';
        
        if (groupMembers.size === 0) {
            container.innerHTML = `
                <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                    Добавьте участников из списка выше
                </div>
            `;
            memberCount.textContent = '0';
            return;
        }
        
        groupMembers.forEach(user => {
            const tag = document.createElement('div');
            tag.className = 'member-tag';
            tag.innerHTML = `
                ${getUserDisplayName(user)}
                <span class="remove" onclick="removeFromGroup('${user.id}')">×</span>
            `;
            container.appendChild(tag);
        });
        
        memberCount.textContent = groupMembers.size;
        document.getElementById('createGroupBtn').disabled = groupMembers.size < 2;
    }

    async function createGroup() {
        const groupName = document.getElementById('groupName').value.trim();
        
        if (!groupName) {
            showNotification('Введите название группы', 'error');
            return;
        }
        
        if (groupMembers.size < 2) {
            showNotification('Добавьте хотя бы 2 участника', 'error');
            return;
        }
        
        showLoading(true);
        try {
            const participants = [currentUser.id, ...Array.from(groupMembers.keys())];
            
            if (authError) {
                const groupId = 'group_' + Date.now();
                const group = {
                    id: groupId,
                    participants: participants,
                    isGroup: true,
                    isChannel: false,
                    groupName: groupName,
                    groupAdmin: currentUser.id,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    lastMessage: 'Группа создана',
                    unreadCount: 0
                };
                
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                chats.push(group);
                localStorage.setItem('absgram_chats', JSON.stringify(chats));
                
                closeGroupModal();
                loadChats();
                showLoading(false);
                return;
            }
            
            const groupData = {
                participants: participants,
                isGroup: true,
                isChannel: false,
                groupName: groupName,
                groupAdmin: currentUser.id,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                lastMessage: 'Группа создана',
                unreadCount: 0
            };
            
            console.log("Создаем группу с данными:", groupData);
            
            const groupRef = await addDoc(collection(db, 'chats'), groupData);
            console.log("Группа создана с ID:", groupRef.id);
            
            closeGroupModal();
            loadChats();
            
        } catch (error) {
            console.error('Ошибка создания группы:', error);
            console.error('Детали ошибки:', error.message);
            showNotification('Ошибка создания группы: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    function showGroupInfo() {
        if (!currentChat || !currentChat.isGroup) return;
        
        document.getElementById('groupInfoName').textContent = currentChat.groupName;
        document.getElementById('groupInfoMembers').textContent = currentChat.participants?.length + ' участников';
        
        const membersList = document.getElementById('groupInfoMembersList');
        membersList.innerHTML = '';
        
        loadGroupMembers().then(() => {
            document.getElementById('groupInfoModal').classList.remove('hidden');
        });
    }

    async function showChannelInfo() {
        if (!currentChat || !currentChat.isChannel) return;
        
        document.getElementById('channelInfoName').textContent = currentChat.channelName;
        document.getElementById('channelInfoDescription').textContent = currentChat.channelDesc || 'Нет описания';
        document.getElementById('channelInfoSubscribers').innerHTML = `👥 ${currentChat.subscriberCount || 1} подписчиков`;
        
        let postsCount = 0;
        if (!authError) {
            const postsQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', currentChat.id)
            );
            const postsSnapshot = await getDocs(postsQuery);
            postsCount = postsSnapshot.size;
        } else {
            const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
            postsCount = messages.filter(m => m.chatId === currentChat.id).length;
        }
        document.getElementById('channelInfoPosts').innerHTML = `📝 ${postsCount} постов`;
        
        const isOwner = currentChat.channelOwner === currentUser.id;
        const isSubscribed = currentChat.participants?.includes(currentUser.id);
        
        document.getElementById('channelAdminSection').style.display = isOwner ? 'block' : 'none';
        document.getElementById('channelSubscribeBtn').style.display = isOwner || isSubscribed ? 'none' : 'inline-block';
        document.getElementById('channelUnsubscribeBtn').style.display = isOwner || !isSubscribed ? 'none' : 'inline-block';
        
        if (currentChat.channelType === 'private') {
            const inviteLink = `absgram://channel/${currentChat.id}`;
            document.getElementById('channelInviteLink').textContent = `🔗 Ссылка: ${inviteLink}`;
        } else {
            document.getElementById('channelInviteLink').textContent = '';
        }
        
        document.getElementById('channelInfoModal').classList.remove('hidden');
    }

    function closeChannelInfoModal() {
        document.getElementById('channelInfoModal').classList.add('hidden');
    }

    async function loadGroupMembers() {
        if (!currentChat || !currentChat.participants) return;
        
        const membersList = document.getElementById('groupInfoMembersList');
        membersList.innerHTML = '';
        
        if (authError) {
            currentChat.participants.forEach(userId => {
                if (userId === currentUser.id) {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.innerHTML = `
                        <div class="group-member-avatar" style="background: ${currentUser.avatarColor || getRandomColor()}; 
                             ${currentUser.avatar ? `background-image: url('${currentUser.avatar}'); background-size: cover; background-position: center;` : ''}">
                            ${currentUser.avatar ? '' : currentUser.name.charAt(0).toUpperCase()}
                        </div>
                        <div class="group-member-name">
                            ${currentUser.name}
                            ${userId === currentChat.groupAdmin ? '<span class="admin-badge">👑</span>' : ''}
                        </div>
                    `;
                    membersList.appendChild(memberItem);
                } else {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.innerHTML = `
                        <div class="group-member-avatar" style="background: ${getRandomColor()}">
                            ?
                        </div>
                        <div class="group-member-name">
                            Неизвестный
                        </div>
                    `;
                    membersList.appendChild(memberItem);
                }
            });
            return;
        }
        
        for (const userId of currentChat.participants) {
            try {
                const userDoc = await getDoc(doc(db, 'users', userId));
                if (userDoc.exists()) {
                    const user = userDoc.data();
                    const isAdmin = userId === currentChat.groupAdmin;
                    
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.innerHTML = `
                        <div class="group-member-avatar" style="background: ${user.avatarColor || getRandomColor()}; 
                             ${user.avatar ? `background-image: url('${user.avatar}'); background-size: cover; background-position: center;` : ''}">
                            ${user.avatar ? '' : user.name.charAt(0).toUpperCase()}
                        </div>
                        <div class="group-member-name">
                            ${getUserDisplayName(user)}
                            ${isAdmin ? '<span class="admin-badge">👑</span>' : ''}
                        </div>
                    `;
                    
                    membersList.appendChild(memberItem);
                }
            } catch (error) {
                console.error('Ошибка загрузки участника:', error);
            }
        }
    }

    function closeGroupInfoModal() {
        document.getElementById('groupInfoModal').classList.add('hidden');
    }

    async function loadChats() {
        if (!currentUser) return;
        
        if (unsubscribeChats) unsubscribeChats();
        
        if (authError) {
            const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
            const userChats = chats.filter(chat => 
                chat.participants && chat.participants.includes(currentUser.id)
            );
            
            userChats.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            
            const chatsWithInfo = userChats.map(chat => {
                if (!chat.isGroup && !chat.isChannel) {
                    const otherUserId = chat.participants.find(id => id !== currentUser.id);
                    const allUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
                    const otherUser = allUsers.find(u => u.id === otherUserId);
                    if (otherUser) {
                        chat.otherUser = otherUser;
                        chat.displayName = getUserDisplayName(otherUser);
                    }
                }
                return chat;
            });
            
            renderChats(chatsWithInfo);
            return;
        }
        
        try {
            const chatsQuery = query(
                collection(db, 'chats'),
                where('participants', 'array-contains', currentUser.id)
            );
            
            unsubscribeChats = onSnapshot(chatsQuery, 
                async (snapshot) => {
                    const chats = [];
                    const chatPromises = [];
                    
                    snapshot.forEach(doc => {
                        const chat = {
                            id: doc.id,
                            ...doc.data()
                        };
                        chats.push(chat);
                        chatPromises.push(loadChatInfo(chat));
                    });
                    
                    await Promise.all(chatPromises);
                    chats.sort((a, b) => {
                        const dateA = a.updatedAt ? (a.updatedAt.toDate ? a.updatedAt.toDate() : new Date(a.updatedAt)) : new Date(0);
                        const dateB = b.updatedAt ? (b.updatedAt.toDate ? b.updatedAt.toDate() : new Date(b.updatedAt)) : new Date(0);
                        return dateB - dateA;
                    });
                    renderChats(chats);
                },
                (error) => {
                    console.error('❌ Ошибка загрузки чатов:', error);
                }
            );
        } catch (error) {
            console.error('❌ Ошибка загрузки чатов:', error);
        }
    }

    async function loadChatInfo(chat) {
        if (chat.isGroup) {
            chat.displayName = chat.groupName;
            chat.isGroupChat = true;
            return;
        }
        
        if (chat.isChannel) {
            chat.displayName = chat.channelName;
            chat.isChannel = true;
            return;
        }
        
        if (!chat.participants || chat.participants.length !== 2) return;
        
        const otherUserId = chat.participants.find(id => id !== currentUser.id);
        if (!otherUserId) return;
        
        if (authError) {
            const allUsers = JSON.parse(localStorage.getItem('absgram_all_users') || '[]');
            const otherUser = allUsers.find(u => u.id === otherUserId);
            if (otherUser) {
                chat.otherUser = otherUser;
                chat.displayName = getUserDisplayName(otherUser);
            } else {
                chat.displayName = 'Неизвестный';
            }
            return;
        }
        
        if (allUsers.has(otherUserId)) {
            chat.otherUser = allUsers.get(otherUserId);
            chat.displayName = getUserDisplayName(chat.otherUser);
            return;
        }
        
        try {
            const userDoc = await getDoc(doc(db, 'users', otherUserId));
            if (userDoc.exists()) {
                const userData = userDoc.data();
                
                const lastActive = userData.lastActive ? 
                    (userData.lastActive.toDate ? userData.lastActive.toDate() : new Date(userData.lastActive)) : 
                    new Date(0);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                
                chat.otherUser = {
                    id: otherUserId,
                    ...userData,
                    realIsOnline: diffMinutes < 2
                };
                allUsers.set(otherUserId, chat.otherUser);
                chat.displayName = getUserDisplayName(chat.otherUser);
                
                if (!allUsersCache.has(otherUserId)) {
                    allUsersCache.set(otherUserId, chat.otherUser);
                }
            }
        } catch (error) {
            console.error('Ошибка загрузки участника чата:', error);
        }
    }

    function renderChats(chats) {
        const container = document.getElementById('chatsList');
        
        if (!chats || chats.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="icon">💬</div>
                    <p>У вас пока нет чатов</p>
                    <p style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                        Начните поиск пользователей, чтобы начать общение
                    </p>
                    <p style="font-size: 12px; margin-top: 5px; color: var(--text-secondary);">
                        🔍 Нажмите на кнопку "+" или введите имя в поиске
                    </p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = '';
        
        chats.forEach(chat => {
            const div = document.createElement('div');
            div.className = `chat-item ${chat.isGroup ? 'group-chat' : ''} ${chat.isChannel ? 'channel' : ''}`;
            div.dataset.chatId = chat.id;
            if (currentChat && currentChat.id === chat.id) {
                div.classList.add('active');
            }
            div.onclick = () => openChat(chat);
            
            const displayName = chat.displayName || (chat.isGroup ? chat.groupName : chat.isChannel ? chat.channelName : 'Неизвестный');
            const lastMessage = chat.lastMessage || 'Нет сообщений';
            const lastTime = chat.updatedAt ? formatTime(chat.updatedAt) : '';
            const isGroup = chat.isGroup;
            const isChannel = chat.isChannel;
            const avatarColor = isGroup ? getRandomColor() : isChannel ? getRandomColor() : (chat.otherUser?.avatarColor || getRandomColor());
            const avatarText = isGroup ? '👥' : isChannel ? '📢' : (chat.otherUser?.name?.charAt(0).toUpperCase() || '?');
            
            let lastMessageIcon = '';
            if (lastMessage.includes('[Файл]') || lastMessage.includes('📎')) {
                lastMessageIcon = '📎 ';
            } else if (lastMessage.includes('[Голосовое]') || lastMessage.includes('🎤')) {
                lastMessageIcon = '🎤 ';
            } else if (lastMessage.includes('[Изображение]') || lastMessage.includes('🖼️')) {
                lastMessageIcon = '🖼️ ';
            } else if (lastMessage.includes('[Видео]') || lastMessage.includes('🎬')) {
                lastMessageIcon = '🎬 ';
            } else if (lastMessage.includes('[Аудио]') || lastMessage.includes('🎵')) {
                lastMessageIcon = '🎵 ';
            } else if (lastMessage.includes('📞')) {
                lastMessageIcon = '📞 ';
            }
            
            div.innerHTML = `
                <div class="chat-avatar ${isGroup ? 'group-avatar' : isChannel ? 'channel-avatar' : ''}" style="background: ${avatarColor}; 
                     ${!isGroup && !isChannel && chat.otherUser?.avatar ? `background-image: url('${chat.otherUser.avatar}'); background-size: cover; background-position: center;` : ''}">
                    ${(!isGroup && !isChannel && chat.otherUser?.avatar) ? '' : avatarText}
                </div>
                <div class="chat-info">
                    <div class="chat-name">${displayName} ${isGroup ? '👥' : ''} ${isChannel ? '📢' : ''}</div>
                    <div class="chat-last">${lastMessageIcon}${lastMessage.length > 30 ? lastMessage.substring(0, 30) + '...' : lastMessage}</div>
                    ${lastTime ? `<div class="chat-time">${lastTime}</div>` : ''}
                </div>
            `;
            
            const unreadCount = unreadCounts.get(chat.id) || 0;
            if (unreadCount > 0) {
                const badge = document.createElement('div');
                badge.className = 'chat-unread-badge';
                badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                const infoDiv = div.querySelector('.chat-info');
                infoDiv.appendChild(badge);
            }
            
            container.appendChild(div);
        });
    }

    async function openChat(chat) {
        if (!currentUser) return;
        
        currentChat = chat;
        
        await markMessagesAsRead(chat.id);
        
        if (!authError && !chat.isGroup && !chat.isChannel) {
            setupTypingListener(chat.id);
            setupCallRingingListener(chat.id);
        }
        
        if (chat.isGroup) {
            document.getElementById('chatTitle').textContent = chat.groupName + ' 👥';
            document.getElementById('chatStatus').textContent = chat.participants?.length + ' участников';
            document.getElementById('chatStatus').style.color = '#FFB347';
            document.getElementById('groupInfoBtn').style.display = 'block';
            document.getElementById('channelInfoBtn').style.display = 'none';
            document.getElementById('contactOptionsBtn').style.display = 'none';
            document.getElementById('callBtn').style.display = 'none';
            document.getElementById('videoCallBtn').style.display = 'none';
            document.getElementById('disableCallBtn').style.display = 'none';
            document.getElementById('videoMessageBtn').style.display = 'flex';
        } else if (chat.isChannel) {
            document.getElementById('chatTitle').textContent = chat.channelName + ' 📢';
            document.getElementById('chatStatus').textContent = `${chat.subscriberCount || 1} подписчиков`;
            document.getElementById('chatStatus').style.color = '#8BC34A';
            document.getElementById('groupInfoBtn').style.display = 'none';
            document.getElementById('channelInfoBtn').style.display = 'block';
            document.getElementById('contactOptionsBtn').style.display = 'none';
            document.getElementById('callBtn').style.display = 'none';
            document.getElementById('videoCallBtn').style.display = 'none';
            document.getElementById('disableCallBtn').style.display = 'none';
            document.getElementById('videoMessageBtn').style.display = chat.channelOwner === currentUser.id ? 'flex' : 'none';
        } else {
            const otherUser = chat.otherUser || {};
            const displayName = getUserDisplayName(otherUser);
            document.getElementById('chatTitle').textContent = displayName;
            
            if (otherUser.realIsOnline === true) {
                document.getElementById('chatStatus').innerHTML = '<span class="user-status real-online">🟢 online</span>';
                document.getElementById('chatStatus').style.color = '#4CAF50';
            } else {
                document.getElementById('chatStatus').innerHTML = '<span class="user-status real-offline">⚫ не в сети</span>';
                document.getElementById('chatStatus').style.color = '#aaa';
            }
            
            document.getElementById('groupInfoBtn').style.display = 'none';
            document.getElementById('channelInfoBtn').style.display = 'none';
            document.getElementById('contactOptionsBtn').style.display = 'flex';
            document.getElementById('disableCallBtn').style.display = 'flex';
            document.getElementById('videoMessageBtn').style.display = 'flex';
            
            updateCallButtonsVisibility();
            
            checkActiveCallsInChat();
            
            setupChatUserStatusListener();
        }
        
        showScreen('chatScreen');
        
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '<div class="empty-state"><div class="loading"></div><p style="margin-top: 10px;">Загрузка сообщений...</p></div>';
        
        document.getElementById('sendMessageBtn').disabled = true;
        document.getElementById('messageInput').focus();
        
        loadMessages(chat.id);
    }

    async function checkActiveCallsInChat() {
        if (!currentChat || currentChat.isGroup || currentChat.isChannel) return;
        
        try {
            const callsQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', currentChat.id),
                where('type', '==', 'call'),
                where('callActive', '==', true)
            );
            
            const snapshot = await getDocs(callsQuery);
            if (!snapshot.empty) {
                const callDoc = snapshot.docs.find(doc => doc.data().callActive === true);
                if (callDoc) {
                    const callData = callDoc.data();
                    currentCallId = callData.callId;
                    
                    if (callData.senderId !== currentUser.id && !activeCall) {
                        showNotification('В этом чате есть активный звонок. Нажмите кнопку присоединиться в сообщении.', 'info');
                    }
                }
            }
        } catch (error) {
            console.error('Ошибка проверки активных звонков:', error);
        }
    }

    // ==== НОВАЯ ФУНКЦИЯ ДЛЯ ДОБАВЛЕНИЯ РАЗДЕЛИТЕЛЕЙ ДАТ ====
    function addDateSeparators(messages) {
        const container = document.getElementById('messagesContainer');
        const oldSeparators = container.querySelectorAll('.date-separator');
        oldSeparators.forEach(el => el.remove());

        if (!messages || messages.length === 0) return;

        let lastDateStr = '';
        messages.forEach((msg, index) => {
            if (!msg.createdAt) return;
            const dateObj = msg.createdAt.toDate ? msg.createdAt.toDate() : new Date(msg.createdAt);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            let displayDate;
            if (dateObj.toDateString() === today.toDateString()) {
                displayDate = 'Сегодня';
            } else if (dateObj.toDateString() === yesterday.toDateString()) {
                displayDate = 'Вчера';
            } else {
                displayDate = dateObj.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
            }

            if (displayDate !== lastDateStr) {
                const separator = document.createElement('div');
                separator.className = 'date-separator';
                separator.innerHTML = `<span>${displayDate}</span>`;
                container.insertBefore(separator, document.getElementById(`message-${msg.id}`) || null);
                lastDateStr = displayDate;
            }
        });
    }

    function loadMessages(chatId) {
        if (unsubscribeMessages) unsubscribeMessages();
        
        if (authError) {
            const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]')
                .filter(msg => msg.chatId === chatId)
                .sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            
            const container = document.getElementById('messagesContainer');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">💭</div>
                        <p>Начните общение!</p>
                        <p style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                            Отправьте первое сообщение
                        </p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            messages.forEach(msg => {
                addMessageToChat(msg);
            });
            
            addDateSeparators(messages); // <-- ДОБАВЛЯЕМ РАЗДЕЛИТЕЛИ ДАТ
            
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);
            
            return;
        }
        
        try {
            const messagesQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', chatId),
                orderBy('createdAt', 'asc')
            );
            
            unsubscribeMessages = onSnapshot(messagesQuery, 
                (snapshot) => {
                    const container = document.getElementById('messagesContainer');
                    const messages = [];
                    
                    snapshot.forEach(doc => {
                        const messageData = doc.data();
                        messages.push({
                            id: doc.id,
                            ...messageData
                        });
                    });
                    
                    if (messages.length === 0) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <div class="icon">💭</div>
                                <p>Начните общение!</p>
                                <p style="font-size: 14px; margin-top: 10px; color: var(--text-secondary);">
                                    Отправьте первое сообщение
                                </p>
                            </div>
                        `;
                        return;
                    }
                    
                    container.innerHTML = '';
                    
                    const senderPromises = messages.map(async msg => {
                        if (msg.senderId === currentUser.id) {
                            msg.senderName = currentUser.name;
                        } else if (msg.senderId === 'system') {
                            msg.senderName = 'System';
                        } else {
                            if (allUsers.has(msg.senderId)) {
                                const user = allUsers.get(msg.senderId);
                                msg.senderName = getUserDisplayName(user);
                            } else {
                                try {
                                    const userDoc = await getDoc(doc(db, 'users', msg.senderId));
                                    if (userDoc.exists()) {
                                        const userData = userDoc.data();
                                        allUsers.set(msg.senderId, userData);
                                        msg.senderName = getUserDisplayName(userData);
                                    } else {
                                        msg.senderName = 'Неизвестный';
                                    }
                                } catch (error) {
                                    msg.senderName = 'Неизвестный';
                                }
                            }
                        }
                        return msg;
                    });
                    
                    Promise.all(senderPromises).then(messagesWithSenders => {
                        messagesWithSenders.forEach(msg => {
                            addMessageToChat(msg);
                        });
                        addDateSeparators(messagesWithSenders); // <-- ДОБАВЛЯЕМ РАЗДЕЛИТЕЛИ ДАТ
                        setTimeout(() => {
                            container.scrollTop = container.scrollHeight;
                        }, 100);
                    });
                    
                },
                (error) => {
                    console.error('❌ Ошибка загрузки сообщений:', error);
                    
                    const container = document.getElementById('messagesContainer');
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="icon">⚠️</div>
                            <p>Ошибка загрузки сообщений</p>
                            <p style="font-size: 12px; margin-top: 10px; color: var(--error);">
                                Код ошибки: ${error.code || 'неизвестно'}
                            </p>
                        </div>
                    `;
                }
            );
        } catch (error) {
            console.error('Ошибка при подписке на сообщения:', error);
        }
    }

    function addMessageToChat(message) {
        const container = document.getElementById('messagesContainer');
        const isOwn = message.senderId === currentUser.id;
        const isSystem = message.senderId === 'system';
        const messageId = message.id || 'msg_' + Date.now();
        
        if (document.getElementById(`message-${messageId}`)) {
            return;
        }
        
        const div = document.createElement('div');
        div.id = `message-${messageId}`;
        
        if (message.type === 'call') {
            if (isCallDisabled && !isOwn) {
                div.className = 'message call-disabled-message';
                div.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px;">🔕</div>
                        <div>Звонок заблокирован (звонки отключены)</div>
                        <div style="font-size: 12px; margin-top: 5px;">${message.senderName || 'Неизвестный'} пытался позвонить</div>
                    </div>
                `;
            } else {
                div.className = 'message call-message';
            }
        } else if (message.type === 'call_end') {
            div.className = 'message call-message';
        } else if (message.type === 'video' && message.isVideoCircle) {
            div.className = `message ${isOwn ? 'message-out' : 'message-in'} fade-in`;
            
            let content = '';
            const isLargeVideo = message.fileId && message.fileId.startsWith('video_');
            
            if (isLargeVideo) {
                content = `
                    <div>🎬 Видеосообщение (большое)</div>
                    <div class="file-message" onclick="downloadLargeVideo('${message.fileId}')">
                        <div class="file-icon">🎬</div>
                        <div class="file-info">
                            <div class="file-name">${message.fileName || 'videomessage.webm'}</div>
                            <div class="file-size">${formatFileSize(message.fileSize || 0)}</div>
                        </div>
                    </div>
                    <div class="video-chunk-info">
                        <div>Видео загружено по частям (${formatFileSize(message.fileSize || 0)})</div>
                    </div>
                    <button class="file-download-btn" onclick="downloadLargeVideo('${message.fileId}')">
                        ⬇️ Скачать видео
                    </button>
                `;
            } else {
                content = `
                    <div>🎬 Видеосообщение</div>
                    <div class="video-circle-message" onclick="playVideoMessage('${message.fileData || ''}', ${message.duration || 0})">
                        <div class="video-circle-play-btn">▶️</div>
                        <div class="video-circle-duration">${message.duration || 0}s</div>
                        <div class="video-circle-progress">
                            <div class="video-circle-progress-bar" id="video-progress-${messageId}"></div>
                        </div>
                    </div>
                    <button class="file-download-btn" onclick="downloadFileFromMessage('${message.fileData || ''}', '${message.fileName || 'videomessage.webm'}', '${message.fileType || 'video/webm'}')">
                        ⬇️ Скачать видео
                    </button>
                `;
            }
            
            div.innerHTML = content;
            
        } else if (message.type === 'file' || message.type === 'image' || (message.type === 'video' && !message.isVideoCircle)) {
            div.className = `message ${isOwn ? 'message-out' : 'message-in'} fade-in`;
            
            if (isOwn && currentFileUploads.has(messageId)) {
                const uploadData = currentFileUploads.get(messageId);
                const sendingIndicator = document.createElement('div');
                sendingIndicator.className = 'sending-indicator';
                sendingIndicator.innerHTML = '<div class="loading"></div>';
                
                const progressContainer = createUploadProgress(messageId, uploadData.fileName, uploadData.fileSize);
                progressContainer.container.style.position = 'relative';
                progressContainer.container.style.marginTop = '10px';
                
                div.appendChild(sendingIndicator);
                div.appendChild(progressContainer.container);
                
                if (uploadData.progress > 0) {
                    progressContainer.progressBar.style.width = `${uploadData.progress}%`;
                    progressContainer.text.textContent = `Загрузка: ${uploadData.progress}%`;
                }
            }
        } else {
            div.className = `message ${isOwn ? 'message-out' : 'message-in'} fade-in`;
            
            if (isOwn && message.sending) {
                const sendingIndicator = document.createElement('div');
                sendingIndicator.className = 'sending-indicator';
                sendingIndicator.innerHTML = '<div class="loading"></div>';
                div.appendChild(sendingIndicator);
            }
        }
        
        const time = message.createdAt ? formatTime(message.createdAt) : 'только что';
        
        let statusIcon = '';
        if (isOwn) {
            if (message.read) {
                statusIcon = '<span class="message-status status-read">✓✓</span>';
            } else {
                statusIcon = '<span class="message-status status-sent">✓</span>';
            }
        }
        
        let content = '';
        let reactionsHTML = '';
        
        if (message.reactions) {
            const reactions = [];
            for (const [emoji, users] of Object.entries(message.reactions)) {
                if (users && users.length > 0) {
                    const count = users.length;
                    const isOwnReaction = users.includes(currentUser.id);
                    reactions.push(`
                        <div class="reaction-badge ${isOwnReaction ? 'own-reaction' : ''}" onclick="addReaction('${messageId}', '${emoji}')">
                            ${emoji} ${count}
                        </div>
                    `);
                }
            }
            if (reactions.length > 0) {
                reactionsHTML = `<div class="message-reactions">${reactions.join('')}</div>`;
            }
        }

        let replyHTML = '';
        if (message.replyTo) {
            const replyText = message.replyTo.text || (message.replyTo.type === 'image' ? '📷 Изображение' : 'Сообщение');
            replyHTML = `
                <div class="reply-preview">
                    <div class="reply-sender">${message.replyTo.senderName || 'Пользователь'}</div>
                    <div class="reply-text">${replyText.length > 30 ? replyText.substring(0, 30) + '...' : replyText}</div>
                </div>
            `;
        }
        
        if (message.type === 'call' && !(isCallDisabled && !isOwn)) {
            const isActive = message.callActive === true;
            const canJoin = isActive && 
                          (message.senderId !== currentUser.id || 
                           (currentCallId === message.callId && activeCall));
            
            content = `
                ${replyHTML}
                <div style="text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 10px;">${message.callType === 'video' ? '📹' : '📞'}</div>
                    <div>${message.text}</div>
                    ${canJoin ? `
                        <button class="join-call-message-btn" data-call-id="${message.callId}" style="margin-top: 15px;">
                            📞 Присоединиться к звонку
                        </button>
                    ` : ''}
                </div>
            `;
        } else if (message.type === 'call_end') {
            content = `
                ${replyHTML}
                <div style="text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 10px;">${message.text.includes('видео') ? '📹' : '📞'}</div>
                    <div>${message.text}</div>
                </div>
            `;
        } else if (message.type === 'file' || message.type === 'image' || message.type === 'video') {
            const isLargeFile = message.fileId && (message.fileId.startsWith('file_') || message.fileId.startsWith('video_'));
            const fileId = message.fileId || message.fileData;
            
            if (message.type === 'image' && !isLargeFile && message.fileData && message.fileData.startsWith('data:image')) {
                content = `
                    ${replyHTML}
                    <div>${message.text || 'Изображение'}</div>
                    <div class="image-message">
                        <img src="${message.fileData}" alt="${message.fileName}" style="max-height: 400px; cursor: zoom-in;" onclick="previewImage('${message.fileData}', '${message.fileName}')">
                    </div>
                    <button class="file-download-btn" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                        ⬇️ Скачать и сохранить в AbSgram
                    </button>
                `;
            } else if (message.type === 'video' && !message.isVideoCircle && !isLargeFile && message.fileData && message.fileData.startsWith('data:video')) {
                content = `
                    ${replyHTML}
                    <div>${message.text || 'Видео'}</div>
                    <div class="video-message" onclick="previewVideo('${message.fileData}', '${message.fileName}')">
                        <video style="width: 100%; max-height: 400px; border-radius: 10px;">
                            <source src="${message.fileData}" type="${message.fileType}">
                            Ваш браузер не поддерживает видео.
                        </video>
                        <div class="video-play-btn">▶️</div>
                    </div>
                    <button class="file-download-btn" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                        ⬇️ Скачать и сохранить в AbSgram
                    </button>
                `;
            } else {
                content = `
                    ${replyHTML}
                    <div>${message.text || (message.type === 'image' ? 'Изображение' : message.type === 'video' ? 'Видео' : 'Файл')}</div>
                    <div class="file-message" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                        <div class="file-icon">${getFileIcon(message.fileType)}</div>
                        <div class="file-info">
                            <div class="file-name">${message.fileName}</div>
                            <div class="file-size">${formatFileSize(message.fileSize)}</div>
                        </div>
                    </div>
                    ${isLargeFile ? '<div class="file-size-warning">📦 Файл отправлен по частям</div>' : ''}
                    <button class="file-download-btn" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                        ⬇️ Скачать и сохранить в AbSgram
                    </button>
                `;
            }
        } else if (message.type === 'audio') {
            const isLargeFile = message.fileId && message.fileId.startsWith('file_');
            const fileId = message.fileId || message.fileData;
            content = `
                ${replyHTML}
                <div>${message.text || 'Аудио'}</div>
                <div class="file-message" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                    <div class="file-icon">🎵</div>
                    <div class="file-info">
                        <div class="file-name">${message.fileName}</div>
                        <div class="file-size">${formatFileSize(message.fileSize)}</div>
                    </div>
                </div>
                <button class="file-download-btn" onclick="saveFileToDevice('${fileId}', '${message.fileName}', '${message.fileType}', ${isLargeFile})">
                    ⬇️ Скачать и сохранить в AbSgram
                </button>
            `;
        } else if (message.type === 'voice') {
            const duration = message.duration ? Math.round(message.duration) : 0;
            content = `
                ${replyHTML}
                <div>Голосовое сообщение</div>
                <div class="voice-message" onclick="playVoiceMessage('${message.voiceData}')">
                    <div class="voice-icon">🎤</div>
                    <div class="voice-duration">${duration}s</div>
                    <div class="voice-wave"></div>
                </div>
                <button class="file-download-btn" onclick="downloadVoiceMessage('${message.voiceData}', '${duration}')">
                    ⬇️ Скачать аудио
                </button>
            `;
        } else {
            const text = message.text.replace(/\n/g, '<br>');
            const edited = message.edited ? ' <span style="font-size: 10px; opacity: 0.6;">(ред.)</span>' : '';
            content = `
                ${replyHTML}
                <div>${text}${edited}</div>
            `;
        }
        
        const actionsHTML = `
            <div class="message-actions">
                <button class="message-action-btn" onclick="setReply('${messageId}', '${message.text?.replace(/'/g, "\\'") || ''}', '${message.senderName || ''}', '${message.type || 'text'}')">↩️</button>
                ${isOwn ? `<button class="message-action-btn" onclick="showEditMessageModal('${messageId}', '${message.text?.replace(/'/g, "\\'") || ''}')">✏️</button>` : ''}
                <button class="message-action-btn" onclick="showCustomReactionModal('${messageId}')">➕</button>
                ${isOwn ? `<button class="message-action-btn" onclick="deleteMessage('${messageId}')">❌</button>` : ''}
            </div>
        `;
        
        if (!div.innerHTML.includes(content) && !(message.type === 'video' && message.isVideoCircle)) {
            if (currentChat && currentChat.isGroup && !isOwn && !isSystem) {
                div.innerHTML = `
                    <div class="message-sender">${message.senderName || 'Неизвестный'}</div>
                    ${content}
                    ${reactionsHTML}
                    <div class="message-time">${time} ${statusIcon}</div>
                    ${actionsHTML}
                `;
            } else {
                div.innerHTML = `
                    ${content}
                    ${reactionsHTML}
                    <div class="message-time">${time} ${statusIcon}</div>
                    ${actionsHTML}
                `;
            }
        }
        
        container.appendChild(div);
        
        setTimeout(() => {
            container.scrollTop = container.scrollHeight;
        }, 100);
    }

    async function sendMessage() {
        if (isSendingMessage) return;
        
        const input = document.getElementById('messageInput');
        const text = input.value.trim();
        
        if (!text || !currentChat || !currentUser) return;
        
        isSendingMessage = true;
        const btn = document.getElementById('sendMessageBtn');
        const btnText = btn.innerHTML;
        btn.innerHTML = '<div class="loading"></div>';
        btn.disabled = true;
        
        try {
            const messageId = 'msg_' + Date.now();
            
            if (authError) {
                const message = {
                    id: messageId,
                    chatId: currentChat.id,
                    senderId: currentUser.id,
                    text: text,
                    type: 'text',
                    createdAt: new Date().toISOString(),
                    read: false,
                    senderName: currentUser.name,
                    sending: true,
                    replyTo: currentReplyTo ? { id: currentReplyTo.id, text: currentReplyTo.text, senderName: currentReplyTo.senderName, type: currentReplyTo.type } : null
                };
                
                addMessageToChat(message);
                
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                messages.push(message);
                localStorage.setItem('absgram_messages', JSON.stringify(messages));
                
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const chatIndex = chats.findIndex(c => c.id === currentChat.id);
                if (chatIndex !== -1) {
                    chats[chatIndex].lastMessage = text.length > 50 ? text.substring(0, 50) + '...' : text;
                    chats[chatIndex].updatedAt = new Date().toISOString();
                    localStorage.setItem('absgram_chats', JSON.stringify(chats));
                }
                
                setTimeout(() => {
                    const messageElement = document.getElementById(`message-${messageId}`);
                    if (messageElement) {
                        const sendingIndicator = messageElement.querySelector('.sending-indicator');
                        if (sendingIndicator) {
                            sendingIndicator.remove();
                        }
                    }
                }, 1000);
                
                input.value = '';
                input.style.height = 'auto';
                
                loadChats();
                
                btn.innerHTML = btnText;
                btn.disabled = true;
                isSendingMessage = false;
                input.focus();
                cancelReply();
                return;
            }
            
            const tempMessage = {
                id: messageId,
                chatId: currentChat.id,
                senderId: currentUser.id,
                text: text,
                type: 'text',
                createdAt: new Date(),
                senderName: currentUser.name,
                sending: true,
                replyTo: currentReplyTo ? { id: currentReplyTo.id, text: currentReplyTo.text, senderName: currentReplyTo.senderName, type: currentReplyTo.type } : null
            };
            
            addMessageToChat(tempMessage);
            
            const messageData = {
                chatId: currentChat.id,
                senderId: currentUser.id,
                text: text,
                type: 'text',
                createdAt: serverTimestamp(),
                read: false,
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    text: currentReplyTo.text,
                    senderName: currentReplyTo.senderName,
                    type: currentReplyTo.type
                } : null
            };
            
            const docRef = await addDoc(collection(db, 'messages'), messageData);
            
            await updateDoc(doc(db, 'chats', currentChat.id), {
                lastMessage: text.length > 50 ? text.substring(0, 50) + '...' : text,
                updatedAt: serverTimestamp()
            });
            
            const messageElement = document.getElementById(`message-${messageId}`);
            if (messageElement) {
                const sendingIndicator = messageElement.querySelector('.sending-indicator');
                if (sendingIndicator) {
                    sendingIndicator.remove();
                }
            }
            
            input.value = '';
            input.style.height = 'auto';
            
            loadChats();
            
            if (!currentChat.isGroup && !currentChat.isChannel) {
                updateTypingStatus(false);
            }
            
        } catch (error) {
            console.error('❌ Ошибка отправки сообщения:', error);
            showNotification('Ошибка отправки сообщения', 'error');
            
            const messageElement = document.getElementById(`message-${messageId}`);
            if (messageElement) {
                const sendingIndicator = messageElement.querySelector('.sending-indicator');
                if (sendingIndicator) {
                    sendingIndicator.remove();
                }
            }
            
            btn.innerHTML = btnText;
            btn.disabled = false;
            isSendingMessage = false;
            return;
        }
        
        btn.innerHTML = btnText;
        btn.disabled = true;
        isSendingMessage = false;
        cancelReply();
        
        input.focus();
    }

    async function deleteMessage(messageId) {
        if (!confirm('Удалить это сообщение?')) return;
        
        try {
            if (authError) {
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                const index = messages.findIndex(m => m.id === messageId);
                if (index !== -1) {
                    messages.splice(index, 1);
                    localStorage.setItem('absgram_messages', JSON.stringify(messages));
                    loadMessages(currentChat.id);
                }
                return;
            }
            
            const messageRef = doc(db, 'messages', messageId);
            await deleteDoc(messageRef);
            showNotification('Сообщение удалено', 'success');
        } catch (error) {
            console.error('Ошибка удаления сообщения:', error);
            showNotification('Ошибка удаления', 'error');
        }
    }

    function setReply(messageId, text, senderName, type) {
        currentReplyTo = { id: messageId, text: text, senderName: senderName, type: type };
        document.getElementById('replyToText').textContent = `${senderName}: ${text.length > 30 ? text.substring(0, 30) + '...' : text}`;
        document.getElementById('replyingIndicator').classList.remove('hidden');
        document.getElementById('messageInput').focus();
    }

    function cancelReply() {
        currentReplyTo = null;
        document.getElementById('replyingIndicator').classList.add('hidden');
    }

    async function handleFileUpload(files) {
        if (!files || !currentChat || !currentUser) return;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            try {
                const maxFileSize = 1024 * 1024 * 1024;
                if (file.size > maxFileSize) {
                    showNotification(`Файл "${file.name}" слишком большой (${formatFileSize(file.size)}). Максимум 1GB.`, 'error');
                    continue;
                }
                
                const fileType = file.type || 'application/octet-stream';
                const fileName = file.name;
                const fileSize = file.size;
                
                const messageType = fileType.startsWith('image/') ? 'image' : 
                                  fileType.startsWith('video/') ? 'video' : 'file';
                
                if (file.size > 512 * 1024) {
                    showNotification(`Файл ${fileName} (${formatFileSize(fileSize)}) большой. Разбиваем на части...`, 'info');
                    const success = await sendLargeFile(file, currentChat.id, messageType);
                    if (success) {
                        loadMessages(currentChat.id);
                        loadChats();
                    }
                } else {
                    const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                    const base64Data = await readFileAsBase64(file);
                    
                    const messageText = fileType.startsWith('image/') ? '[Изображение]' :
                                      fileType.startsWith('video/') ? '[Видео]' : '[Файл]';
                    
                    const messageData = {
                        chatId: currentChat.id,
                        senderId: currentUser.id,
                        text: messageText,
                        type: messageType,
                        fileData: base64Data,
                        fileName: fileName,
                        fileType: fileType,
                        fileSize: fileSize,
                        createdAt: serverTimestamp(),
                        read: false,
                        replyTo: currentReplyTo ? {
                            id: currentReplyTo.id,
                            text: currentReplyTo.text,
                            senderName: currentReplyTo.senderName,
                            type: currentReplyTo.type
                        } : null
                    };
                    
                    await addDoc(collection(db, 'messages'), messageData);
                    
                    let lastMessage = messageText;
                    if (messageType === 'image') {
                        lastMessage = '🖼️ Изображение';
                    } else if (messageType === 'video') {
                        lastMessage = '🎬 Видео';
                    } else {
                        lastMessage = `📎 ${fileName.substring(0, 20)}${fileName.length > 20 ? '...' : ''}`;
                    }
                    
                    await updateDoc(doc(db, 'chats', currentChat.id), {
                        lastMessage: lastMessage,
                        updatedAt: serverTimestamp()
                    });
                    
                    showNotification('Файл отправлен', 'success');
                }
                
            } catch (error) {
                console.error('Ошибка обработки файла:', error);
                showNotification(`Ошибка отправки файла "${file.name}": ${error.message}`, 'error');
            }
        }
        
        document.getElementById('fileUpload').value = '';
        cancelReply();
    }

    function startVoiceRecording() {
        if (isRecording) return;
        
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showNotification('Ваш браузер не поддерживает запись аудио', 'error');
            return;
        }
        
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    sendVoiceMessage(audioBlob);
                    
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                document.getElementById('voiceBtn').classList.add('recording');
                document.getElementById('recordingTime').style.display = 'block';
                
                recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('recordingTime').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (elapsed >= 120) {
                        stopVoiceRecording();
                    }
                }, 1000);
            })
            .catch(error => {
                console.error('Ошибка доступа к микрофону:', error);
                showNotification('Не удалось получить доступ к микрофону', 'error');
            });
    }

    function stopVoiceRecording() {
        if (!isRecording || !mediaRecorder) return;
        
        mediaRecorder.stop();
        isRecording = false;
        
        if (recordingTimer) {
            clearInterval(recordingTimer);
            recordingTimer = null;
        }
        
        document.getElementById('voiceBtn').classList.remove('recording');
        document.getElementById('recordingTime').style.display = 'none';
    }

    async function sendVoiceMessage(audioBlob) {
        if (!currentChat || !currentUser) return;
        
        showLoading(true);
        
        try {
            const reader = new FileReader();
            reader.onload = async function(event) {
                const base64Audio = event.target.result;
                const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
                
                if (authError) {
                    const messageId = 'msg_' + Date.now();
                    const message = {
                        id: messageId,
                        chatId: currentChat.id,
                        senderId: currentUser.id,
                        text: '[Голосовое сообщение]',
                        type: 'voice',
                        voiceData: base64Audio,
                        duration: duration,
                        createdAt: new Date().toISOString(),
                        read: false,
                        senderName: currentUser.name,
                        replyTo: currentReplyTo ? { id: currentReplyTo.id, text: currentReplyTo.text, senderName: currentReplyTo.senderName, type: currentReplyTo.type } : null
                    };
                    
                    const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                    messages.push(message);
                    localStorage.setItem('absgram_messages', JSON.stringify(messages));
                    
                    const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                    const chatIndex = chats.findIndex(c => c.id === currentChat.id);
                    if (chatIndex !== -1) {
                        chats[chatIndex].lastMessage = '🎤 Голосовое сообщение';
                        chats[chatIndex].updatedAt = new Date().toISOString();
                        localStorage.setItem('absgram_chats', JSON.stringify(chats));
                    }
                    
                    addMessageToChat(message);
                    loadChats();
                    showNotification('Голосовое сообщение отправлено', 'success');
                    showLoading(false);
                    return;
                }
                
                const messageData = {
                    chatId: currentChat.id,
                    senderId: currentUser.id,
                    text: '[Голосовое сообщение]',
                    type: 'voice',
                    voiceData: base64Audio,
                    duration: duration,
                    createdAt: serverTimestamp(),
                    read: false,
                    replyTo: currentReplyTo ? {
                        id: currentReplyTo.id,
                        text: currentReplyTo.text,
                        senderName: currentReplyTo.senderName,
                        type: currentReplyTo.type
                    } : null
                };
                
                await addDoc(collection(db, 'messages'), messageData);
                
                await updateDoc(doc(db, 'chats', currentChat.id), {
                    lastMessage: '🎤 Голосовое сообщение',
                    updatedAt: serverTimestamp()
                });
                
                showNotification('Голосовое сообщение отправлено', 'success');
                loadChats();
                showLoading(false);
            };
            
            reader.readAsDataURL(audioBlob);
            
        } catch (error) {
            console.error('Ошибка отправки голосового сообщения:', error);
            showNotification('Ошибка отправки голосового сообщения', 'error');
            showLoading(false);
        }
        cancelReply();
    }

    function playVoiceMessage(base64Data) {
        const audioPlayer = document.getElementById('audioPlayer');
        audioPlayer.src = base64Data;
        audioPlayer.play();
    }

    function downloadVoiceMessage(base64Data, duration) {
        downloadFileFromMessage(base64Data, `голосовое_сообщение_${duration}с.webm`, 'audio/webm');
    }

    function previewImage(base64Data, fileName) {
        document.getElementById('previewedImage').src = base64Data;
        document.getElementById('imagePreviewModal').classList.remove('hidden');
    }

    function previewVideo(base64Data, fileName) {
        const video = document.getElementById('previewedVideo');
        video.src = base64Data;
        document.getElementById('videoPreviewModal').classList.remove('hidden');
        video.play().catch(e => console.warn('Не удалось воспроизвести видео:', e));
    }

    function playVideoMessage(base64Data, duration) {
        const video = document.getElementById('videoMessagePreview');
        video.src = base64Data;
        document.getElementById('videoMessagePreviewModal').classList.remove('hidden');
        video.play().catch(e => console.warn('Не удалось воспроизвести видео:', e));
    }

    function requestNotificationPermission() {
        if (notificationPermissionAsked) return;
        
        if (!("Notification" in window)) {
            console.log("Этот браузер не поддерживает уведомления.");
            return;
        }
        
        if (Notification.permission === "default") {
            setTimeout(() => {
                if (!notificationPermissionAsked) {
                    document.getElementById('notificationPermission').classList.remove('hidden');
                    notificationPermissionAsked = true;
                }
            }, 5000);
        }
    }

    function setupChatUserStatusListener() {
        if (!currentChat || currentChat.isGroup || currentChat.isChannel || !currentChat.otherUser) return;
        
        try {
            const userRef = doc(db, 'users', currentChat.otherUser.id);
            
            const unsubscribe = onSnapshot(userRef, (doc) => {
                if (doc.exists()) {
                    const userData = doc.data();
                    const lastActive = userData.lastActive ? 
                        (userData.lastActive.toDate ? userData.lastActive.toDate() : new Date(userData.lastActive)) : 
                        new Date(0);
                    const now = new Date();
                    const diffMinutes = Math.floor((now - lastActive) / (1000 * 60));
                    
                    const isOnline = diffMinutes < 2;
                    
                    if (isOnline) {
                        document.getElementById('chatStatus').innerHTML = '<span class="user-status real-online">🟢 online</span>';
                        document.getElementById('chatStatus').style.color = '#4CAF50';
                    } else {
                        document.getElementById('chatStatus').innerHTML = '<span class="user-status real-offline">⚫ не в сети</span>';
                        document.getElementById('chatStatus').style.color = '#aaa';
                    }
                }
            });
            
            return unsubscribe;
        } catch (error) {
            console.error('Ошибка слушателя статуса пользователя:', error);
        }
    }

    function setupOnlineStatusListener() {
        if (!currentUser || authError) return;
        
        try {
            const userRef = doc(db, 'users', currentUser.id);
            
            onlineStatusInterval = setInterval(() => {
                if (!authError) {
                    updateDoc(userRef, {
                        isOnline: true,
                        lastActive: serverTimestamp()
                    }).catch(error => {
                        console.error('Ошибка обновления статуса онлайн:', error);
                    });
                }
            }, 30000);
            
            window.addEventListener('beforeunload', () => {
                if (!authError) {
                    updateDoc(userRef, {
                        isOnline: false,
                        lastActive: serverTimestamp()
                    }).catch(console.error);
                }
            });
            
        } catch (error) {
            console.error('Ошибка настройки слушателя статуса:', error);
        }
    }

    // ==================== ФУНКЦИИ ДЛЯ ВИДЕОСООБЩЕНИЙ ====================
    async function startVideoRecording() {
        try {
            const constraints = {
                video: {
                    facingMode: currentCamera,
                    width: { ideal: 640 },
                    height: { ideal: 640 }
                },
                audio: true
            };
            
            videoStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            const preview = document.getElementById('videoRecordingPreview');
            preview.srcObject = videoStream;
            
            const options = {
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: 2000000
            };
            
            try {
                videoMediaRecorder = new MediaRecorder(videoStream, options);
            } catch (e) {
                console.log('Не поддерживается webm, пробуем mp4:', e);
                videoMediaRecorder = new MediaRecorder(videoStream);
            }
            
            videoChunks = [];
            
            videoMediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    videoChunks.push(event.data);
                }
            };
            
            document.getElementById('videoRecordingModal').classList.remove('hidden');
            
        } catch (error) {
            console.error('Ошибка доступа к камере:', error);
            showNotification('Не удалось получить доступ к камере', 'error');
        }
    }

    function startRecordingVideo() {
        if (!videoMediaRecorder) return;
        
        videoMediaRecorder.start(100);
        isVideoRecording = true;
        videoRecordingStartTime = Date.now();
        
        document.getElementById('recordStartBtn').classList.add('recording');
        document.getElementById('recordStartBtn').style.display = 'none';
        document.getElementById('recordStopBtn').style.display = 'flex';
        document.getElementById('recordingIndicator').style.display = 'flex';
        
        videoRecordingTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - videoRecordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('videoRecordingTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            if (elapsed >= maxVideoDuration) {
                stopRecordingVideo();
            }
        }, 1000);
    }

    function stopRecordingVideo() {
        if (!isVideoRecording || !videoMediaRecorder) return;
        
        videoMediaRecorder.stop();
        isVideoRecording = false;
        
        if (videoRecordingTimer) {
            clearInterval(videoRecordingTimer);
            videoRecordingTimer = null;
        }
        
        document.getElementById('recordStartBtn').classList.remove('recording');
        document.getElementById('recordStartBtn').style.display = 'flex';
        document.getElementById('recordStopBtn').style.display = 'none';
        document.getElementById('recordingIndicator').style.display = 'none';
    }

    async function sendVideoMessage() {
        if (videoChunks.length === 0) {
            showNotification('Видеосообщение пустое', 'error');
            closeVideoRecordingModal();
            return;
        }
        
        showLoading(true);
        
        try {
            const videoBlob = new Blob(videoChunks, { type: 'video/webm' });
            const duration = Math.floor((Date.now() - videoRecordingStartTime) / 1000);
            
            if (videoBlob.size > maxVideoSize) {
                await sendLargeVideoMessage(videoBlob, duration);
            } else {
                await sendSingleVideoMessage(videoBlob, duration);
            }
            
        } catch (error) {
            console.error('Ошибка отправки видеосообщения:', error);
            showNotification('Ошибка отправки видеосообщения', 'error');
        } finally {
            showLoading(false);
            closeVideoRecordingModal();
        }
        cancelReply();
    }

    async function sendSingleVideoMessage(videoBlob, duration) {
        const reader = new FileReader();
        
        reader.onload = async function(event) {
            const base64Video = event.target.result;
            
            if (authError) {
                const messageId = 'msg_' + Date.now();
                const message = {
                    id: messageId,
                    chatId: currentChat.id,
                    senderId: currentUser.id,
                    text: '[Видеосообщение]',
                    type: 'video',
                    fileData: base64Video,
                    fileName: `videomessage_${Date.now()}.webm`,
                    fileType: 'video/webm',
                    fileSize: videoBlob.size,
                    duration: duration,
                    createdAt: new Date().toISOString(),
                    read: false,
                    senderName: currentUser.name,
                    isVideoCircle: true,
                    replyTo: currentReplyTo ? { id: currentReplyTo.id, text: currentReplyTo.text, senderName: currentReplyTo.senderName, type: currentReplyTo.type } : null
                };
                
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                messages.push(message);
                localStorage.setItem('absgram_messages', JSON.stringify(messages));
                
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const chatIndex = chats.findIndex(c => c.id === currentChat.id);
                if (chatIndex !== -1) {
                    chats[chatIndex].lastMessage = '🎬 Видеосообщение';
                    chats[chatIndex].updatedAt = new Date().toISOString();
                    localStorage.setItem('absgram_chats', JSON.stringify(chats));
                }
                
                addMessageToChat(message);
                loadChats();
                showNotification('Видеосообщение отправлено', 'success');
                return;
            }
            
            const messageData = {
                chatId: currentChat.id,
                senderId: currentUser.id,
                text: '[Видеосообщение]',
                type: 'video',
                fileData: base64Video,
                fileName: `videomessage_${Date.now()}.webm`,
                fileType: 'video/webm',
                fileSize: videoBlob.size,
                duration: duration,
                createdAt: serverTimestamp(),
                read: false,
                isVideoCircle: true,
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    text: currentReplyTo.text,
                    senderName: currentReplyTo.senderName,
                    type: currentReplyTo.type
                } : null
            };
            
            await addDoc(collection(db, 'messages'), messageData);
            
            await updateDoc(doc(db, 'chats', currentChat.id), {
                lastMessage: '🎬 Видеосообщение',
                updatedAt: serverTimestamp()
            });
            
            showNotification('Видеосообщение отправлено', 'success');
            loadChats();
        };
        
        reader.readAsDataURL(videoBlob);
    }

    async function sendLargeVideoMessage(videoBlob, duration) {
        showNotification('Видео большое, разбиваем на части...', 'info');
        
        const chunkSize = 500 * 1024;
        const totalChunks = Math.ceil(videoBlob.size / chunkSize);
        const fileId = 'video_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        const videoRecord = {
            fileId: fileId,
            fileName: `videomessage_${Date.now()}.webm`,
            fileType: 'video/webm',
            fileSize: videoBlob.size,
            duration: duration,
            totalChunks: totalChunks,
            uploadedChunks: 0,
            chatId: currentChat.id,
            senderId: currentUser.id,
            senderName: currentUser.name,
            isVideoCircle: true,
            createdAt: serverTimestamp(),
            status: 'uploading'
        };
        
        try {
            const fileRef = await addDoc(collection(db, 'large_videos'), videoRecord);
            
            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, videoBlob.size);
                const chunk = videoBlob.slice(start, end);
                
                const reader = new FileReader();
                const chunkData = await new Promise((resolve, reject) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(chunk);
                });
                
                await addDoc(collection(db, 'video_chunks'), {
                    fileId: fileId,
                    chunkIndex: i,
                    chunkData: chunkData,
                    totalChunks: totalChunks,
                    createdAt: serverTimestamp()
                });
                
                await updateDoc(fileRef, {
                    uploadedChunks: i + 1,
                    updatedAt: serverTimestamp()
                });
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            await updateDoc(fileRef, {
                status: 'completed',
                completedAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });
            
            const messageData = {
                chatId: currentChat.id,
                senderId: currentUser.id,
                text: '[Видеосообщение]',
                type: 'video',
                fileId: fileId,
                fileName: `videomessage_${Date.now()}.webm`,
                fileType: 'video/webm',
                fileSize: videoBlob.size,
                duration: duration,
                createdAt: serverTimestamp(),
                read: false,
                isVideoCircle: true,
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    text: currentReplyTo.text,
                    senderName: currentReplyTo.senderName,
                    type: currentReplyTo.type
                } : null
            };
            
            await addDoc(collection(db, 'messages'), messageData);
            
            await updateDoc(doc(db, 'chats', currentChat.id), {
                lastMessage: '🎬 Видеосообщение (большое)',
                updatedAt: serverTimestamp()
            });
            
            showNotification('Видео загружено по частям', 'success');
            
        } catch (error) {
            console.error('Ошибка отправки большого видео:', error);
            throw error;
        }
    }

    async function downloadLargeVideo(fileId) {
        try {
            showLoading(true);
            
            const videosQuery = query(
                collection(db, 'large_videos'),
                where('fileId', '==', fileId),
                limit(1)
            );
            
            const snapshot = await getDocs(videosQuery);
            if (snapshot.empty) {
                throw new Error('Видео не найдено');
            }
            
            const videoData = snapshot.docs[0].data();
            
            showNotification(`Скачиваем видео ${videoData.fileName}...`, 'info');
            
            const chunksQuery = query(
                collection(db, 'video_chunks'),
                where('fileId', '==', fileId),
                orderBy('chunkIndex', 'asc')
            );
            
            const chunksSnapshot = await getDocs(chunksQuery);
            
            if (chunksSnapshot.size === 0) {
                throw new Error('Чанки не найдены');
            }
            
            const chunks = [];
            chunksSnapshot.forEach(doc => {
                chunks.push(doc.data().chunkData);
            });
            
            if (chunks.length !== videoData.totalChunks) {
                showNotification(`Загружено ${chunks.length} из ${videoData.totalChunks} частей`, 'warning');
            }
            
            const mimeType = videoData.fileType || 'video/webm';
            
            let base64Data = '';
            for (const chunk of chunks) {
                const parts = chunk.split(',');
                if (parts.length > 1) {
                    base64Data += parts[1];
                } else {
                    base64Data += chunk;
                }
            }
            
            const fullBase64 = `data:${mimeType};base64,${base64Data}`;
            
            await saveFileToDevice(fullBase64, videoData.fileName, mimeType, false);
            
        } catch (error) {
            console.error('Ошибка скачивания видео:', error);
            showNotification('Ошибка скачивания видео: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    function switchCamera() {
        currentCamera = currentCamera === 'user' ? 'environment' : 'user';
        
        if (videoStream) {
            videoStream.getTracks().forEach(track => track.stop());
        }
        
        startVideoRecording();
    }

    function closeVideoRecordingModal() {
        document.getElementById('videoRecordingModal').classList.add('hidden');
        
        if (isVideoRecording) {
            stopRecordingVideo();
        }
        
        if (videoStream) {
            videoStream.getTracks().forEach(track => track.stop());
            videoStream = null;
        }
        
        if (videoRecordingTimer) {
            clearInterval(videoRecordingTimer);
            videoRecordingTimer = null;
        }
        
        document.getElementById('videoRecordingTimer').textContent = '00:00';
        document.getElementById('recordStartBtn').classList.remove('recording');
        document.getElementById('recordStartBtn').style.display = 'flex';
        document.getElementById('recordStopBtn').style.display = 'none';
        document.getElementById('recordingIndicator').style.display = 'none';
    }

    async function compressVideo(file, maxSizeMB = 500) {
        return new Promise((resolve, reject) => {
            const maxSizeBytes = maxSizeMB * 1024 * 1024;
            
            if (file.size <= maxSizeBytes) {
                resolve(file);
                return;
            }
            
            showNotification(`Видео слишком большое (${formatFileSize(file.size)}). Максимальный размер 500MB.`, 'error');
            reject(new Error('Файл слишком большой'));
        });
    }

    async function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(file);
        });
    }

    async function sendLargeFile(file, chatId, messageType) {
        try {
            const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const chunkSize = 500 * 1024;
            const totalChunks = Math.ceil(file.size / chunkSize);
            
            showNotification(`Загружаем файл ${file.name} (${totalChunks} частей)...`, 'info');
            
            const fileRecord = {
                fileId: fileId,
                fileName: file.name,
                fileType: file.type,
                fileSize: file.size,
                totalChunks: totalChunks,
                uploadedChunks: 0,
                chatId: chatId,
                senderId: currentUser.id,
                senderName: currentUser.name,
                messageType: messageType,
                createdAt: serverTimestamp(),
                status: 'uploading'
            };
            
            const fileRef = await addDoc(collection(db, 'large_files'), fileRecord);
            
            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                const chunk = file.slice(start, end);
                
                const reader = new FileReader();
                const chunkData = await new Promise((resolve, reject) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(chunk);
                });
                
                await addDoc(collection(db, 'file_chunks'), {
                    fileId: fileId,
                    chunkIndex: i,
                    chunkData: chunkData,
                    totalChunks: totalChunks,
                    createdAt: serverTimestamp()
                });
                
                await updateDoc(fileRef, {
                    uploadedChunks: i + 1,
                    updatedAt: serverTimestamp()
                });
                
                if (file.size > 5 * 1024 * 1024) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            await updateDoc(fileRef, {
                status: 'completed',
                completedAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });
            
            const messageData = {
                chatId: chatId,
                senderId: currentUser.id,
                text: messageType === 'image' ? '[Изображение]' : 
                      messageType === 'video' ? '[Видео]' : '[Файл]',
                type: messageType,
                fileId: fileId,
                fileName: file.name,
                fileType: file.type,
                fileSize: file.size,
                createdAt: serverTimestamp(),
                read: false,
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    text: currentReplyTo.text,
                    senderName: currentReplyTo.senderName,
                    type: currentReplyTo.type
                } : null
            };
            
            await addDoc(collection(db, 'messages'), messageData);
            
            let lastMessage = messageType === 'image' ? '🖼️ Изображение' :
                            messageType === 'video' ? '🎬 Видео' : 
                            `📎 ${file.name.substring(0, 20)}${file.name.length > 20 ? '...' : ''}`;
            
            await updateDoc(doc(db, 'chats', chatId), {
                lastMessage: lastMessage,
                updatedAt: serverTimestamp()
            });
            
            showNotification('Файл успешно загружен', 'success');
            return true;
            
        } catch (error) {
            console.error('Ошибка отправки большого файла:', error);
            showNotification('Ошибка отправки файла: ' + error.message, 'error');
            return false;
        }
    }

    async function downloadLargeFile(fileId) {
        try {
            showLoading(true);
            
            const filesQuery = query(
                collection(db, 'large_files'),
                where('fileId', '==', fileId),
                limit(1)
            );
            
            const snapshot = await getDocs(filesQuery);
            if (snapshot.empty) {
                throw new Error('Файл не найден');
            }
            
            const fileData = snapshot.docs[0].data();
            
            showNotification(`Скачиваем файл ${fileData.fileName}...`, 'info');
            
            const chunksQuery = query(
                collection(db, 'file_chunks'),
                where('fileId', '==', fileId),
                orderBy('chunkIndex', 'asc')
            );
            
            const chunksSnapshot = await getDocs(chunksQuery);
            
            if (chunksSnapshot.size === 0) {
                throw new Error('Чанки не найдены');
            }
            
            const chunks = [];
            chunksSnapshot.forEach(doc => {
                chunks.push(doc.data().chunkData);
            });
            
            if (chunks.length !== fileData.totalChunks) {
                showNotification(`Загружено ${chunks.length} из ${fileData.totalChunks} частей`, 'warning');
            }
            
            const mimeType = fileData.fileType || 'application/octet-stream';
            
            let base64Data = '';
            for (const chunk of chunks) {
                const parts = chunk.split(',');
                if (parts.length > 1) {
                    base64Data += parts[1];
                } else {
                    base64Data += chunk;
                }
            }
            
            const fullBase64 = `data:${mimeType};base64,${base64Data}`;
            
            await saveFileToDevice(fullBase64, fileData.fileName, mimeType, false);
            
        } catch (error) {
            console.error('Ошибка скачивания файла:', error);
            showNotification('Ошибка скачивания файла: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    async function saveFileToDevice(fileDataOrId, fileName, fileType, isLargeFile = false) {
        try {
            showLoading(true);
            showNotification(`Подготовка файла ${fileName}...`, 'info');
            
            let fileBlob;
            let finalMimeType = fileType || 'application/octet-stream';
            
            if (isLargeFile && (fileDataOrId.startsWith('file_') || fileDataOrId.startsWith('video_'))) {
                showLoading(false);
                if (fileDataOrId.startsWith('video_')) {
                    await downloadLargeVideo(fileDataOrId);
                } else {
                    await downloadLargeFile(fileDataOrId);
                }
                return;
            }
            
            if (fileDataOrId.startsWith('data:')) {
                const response = await fetch(fileDataOrId);
                fileBlob = await response.blob();
            } else if (fileDataOrId.startsWith('http') || fileDataOrId.startsWith('blob')) {
                const response = await fetch(fileDataOrId);
                fileBlob = await response.blob();
            } else {
                throw new Error('Неизвестный формат данных');
            }
            
            let category = 'Other';
            if (fileType?.startsWith('image/')) {
                category = 'Images';
            } else if (fileType?.startsWith('video/')) {
                category = 'Videos';
            } else if (fileType?.startsWith('audio/') || fileType?.includes('audio')) {
                category = 'Audio';
            } else if (fileType?.includes('pdf') || fileType?.includes('document') || fileType?.includes('text')) {
                category = 'Documents';
            }
            
            if ('showDirectoryPicker' in window) {
                try {
                    const directoryHandle = await window.showDirectoryPicker({
                        id: 'absgram',
                        mode: 'readwrite',
                        startIn: 'downloads'
                    });
                    
                    let absgramDir;
                    try {
                        absgramDir = await directoryHandle.getDirectoryHandle('AbSgram', { create: true });
                    } catch (e) {
                        absgramDir = directoryHandle;
                    }
                    
                    let categoryDir;
                    try {
                        categoryDir = await absgramDir.getDirectoryHandle(category, { create: true });
                    } catch (e) {
                        categoryDir = absgramDir;
                    }
                    
                    const fileHandle = await categoryDir.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(fileBlob);
                    await writable.close();
                    
                    showNotification(`Файл сохранен в папку AbSgram/${category}`, 'success');
                    showDownloadNotification(fileName);
                    
                } catch (err) {
                    console.warn('File System Access API не сработал, используем стандартное скачивание', err);
                    standardDownload(fileBlob, fileName, finalMimeType);
                }
            } else {
                standardDownload(fileBlob, fileName, finalMimeType);
            }
            
        } catch (error) {
            console.error('Ошибка сохранения файла:', error);
            showNotification('Ошибка сохранения файла: ' + error.message, 'error');
            
            if (fileDataOrId.startsWith('data:')) {
                const link = document.createElement('a');
                link.href = fileDataOrId;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showDownloadNotification(fileName);
            }
        } finally {
            showLoading(false);
        }
    }

    function standardDownload(blob, fileName, mimeType) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showDownloadNotification(fileName);
    }

    function downloadFileFromMessage(fileDataOrId, fileName, fileType) {
        try {
            if (fileDataOrId && (fileDataOrId.startsWith('file_') || fileDataOrId.startsWith('video_'))) {
                saveFileToDevice(fileDataOrId, fileName, fileType, true);
                return;
            }
            
            if (fileDataOrId.startsWith('http') || fileDataOrId.startsWith('blob')) {
                window.open(fileDataOrId, '_blank');
                return;
            }
            
            saveFileToDevice(fileDataOrId, fileName, fileType, false);
            
        } catch (error) {
            console.error('Ошибка скачивания файла:', error);
            try {
                window.open(fileDataOrId, '_blank');
            } catch (e) {
                showNotification('Ошибка скачивания файла', 'error');
            }
        }
    }

    function toggleCallsDisabled() {
        isCallDisabled = !isCallDisabled;
        const disableBtn = document.getElementById('disableCallBtn');
        
        if (isCallDisabled) {
            disableBtn.classList.add('active');
            disableBtn.innerHTML = '🔕';
            disableBtn.title = 'Включить звонки';
            showNotification('Звонки отключены', 'warning');
            
            document.getElementById('callBtn').style.display = 'none';
            document.getElementById('videoCallBtn').style.display = 'none';
            
            if (activeCall) {
                endCall();
            }
        } else {
            disableBtn.classList.remove('active');
            disableBtn.innerHTML = '🔔';
            disableBtn.title = 'Отключить звонки';
            showNotification('Звонки включены', 'success');
            
            if (currentChat && !currentChat.isGroup && !currentChat.isChannel) {
                document.getElementById('callBtn').style.display = 'flex';
                document.getElementById('videoCallBtn').style.display = 'flex';
            }
        }
        
        saveCallsDisabledState();
    }

    function saveCallsDisabledState() {
        if (currentUser) {
            localStorage.setItem(`absgram_calls_disabled_${currentUser.id}`, isCallDisabled);
        }
    }

    function loadCallsDisabledState() {
        if (currentUser) {
            const saved = localStorage.getItem(`absgram_calls_disabled_${currentUser.id}`);
            if (saved !== null) {
                isCallDisabled = saved === 'true';
                const disableBtn = document.getElementById('disableCallBtn');
                
                if (isCallDisabled) {
                    disableBtn.classList.add('active');
                    disableBtn.innerHTML = '🔕';
                    disableBtn.title = 'Включить звонки';
                } else {
                    disableBtn.classList.remove('active');
                    disableBtn.innerHTML = '🔔';
                    disableBtn.title = 'Отключить звонки';
                }
            }
        }
    }

    function updateCallButtonsVisibility() {
        if (!currentChat) return;
        
        if (currentChat.isGroup || currentChat.isChannel || isCallDisabled) {
            document.getElementById('callBtn').style.display = 'none';
            document.getElementById('videoCallBtn').style.display = 'none';
        } else {
            document.getElementById('callBtn').style.display = 'flex';
            document.getElementById('videoCallBtn').style.display = 'flex';
        }
    }

    function showCallTypeModal() {
        if (!currentChat || currentChat.isGroup || currentChat.isChannel) {
            showNotification('Звонки доступны только в личных чатах', 'error');
            return;
        }

        if (activeCall) {
            showNotification('Уже есть активный звонок', 'warning');
            return;
        }

        document.querySelectorAll('.call-type-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        
        selectedCallType = 'audio';
        document.getElementById('audioCallOption').classList.add('selected');
        
        document.getElementById('callTypeModal').classList.remove('hidden');
    }

    async function startCall() {
        if (!currentChat || !currentChat.otherUser) return;
        
        if (isCallDisabled) {
            showNotification('Звонки отключены. Включите их в настройках.', 'warning');
            return;
        }

        try {
            showLoading(true);

            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    { urls: 'stun:stun.ekiga.net' },
                    { urls: 'stun:stun.ideasip.com' },
                    { urls: 'stun:stun.schlund.de' },
                    { urls: 'stun:stun.stunprotocol.org:3478' },
                    { urls: 'stun:stun.voiparound.com' },
                    { urls: 'stun:stun.voipbuster.com' },
                    { urls: 'stun:stun.voipstunt.com' },
                    { urls: 'stun:stun.voxgratia.org' },
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                iceTransportPolicy: 'all',
                iceCandidatePoolSize: 10,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };

            const audioConstraints = {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 48000,
                channelCount: 2,
                sampleSize: 16,
                volume: 1.0
            };

            const videoConstraints = selectedCallType === 'video' ? {
                width: { ideal: 1280, min: 640, max: 1920 },
                height: { ideal: 720, min: 480, max: 1080 },
                frameRate: { ideal: 30, min: 15, max: 60 },
                aspectRatio: 1.7777777778,
                facingMode: 'user'
            } : false;

            const constraints = {
                audio: audioConstraints,
                video: videoConstraints
            };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(localStream);
            const gainNode = audioContext.createGain();
            const compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-50, audioContext.currentTime);
            compressor.knee.setValueAtTime(40, audioContext.currentTime);
            compressor.ratio.setValueAtTime(12, audioContext.currentTime);
            compressor.attack.setValueAtTime(0, audioContext.currentTime);
            compressor.release.setValueAtTime(0.25, audioContext.currentTime);
            
            gainNode.gain.value = 1.2;
            
            source.connect(compressor);
            compressor.connect(gainNode);
            const destination = audioContext.createMediaStreamDestination();
            gainNode.connect(destination);
            
            const videoTracks = localStream.getVideoTracks();
            const enhancedStream = destination.stream;
            videoTracks.forEach(track => enhancedStream.addTrack(track));
            localStream = enhancedStream;
            
            if (selectedCallType === 'video') {
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                document.getElementById('videoContainer').style.display = 'block';
                document.getElementById('audioCallContainer').style.display = 'none';
            } else {
                document.getElementById('videoContainer').style.display = 'none';
                document.getElementById('audioCallContainer').style.display = 'block';
            }

            const callId = generateCallId();
            currentCallId = callId;

            const callMessage = {
                chatId: currentChat.id,
                senderId: currentUser.id,
                senderName: currentUser.name,
                type: 'call',
                callType: selectedCallType,
                callId: callId,
                text: selectedCallType === 'video' ? 
                    `📹 ${currentUser.name} начал HD видеозвонок` : 
                    `📞 ${currentUser.name} начал HD аудиозвонок`,
                createdAt: serverTimestamp(),
                callActive: true,
                recipientId: currentChat.otherUser.id
            };

            const callRef = await addDoc(collection(db, 'messages'), callMessage);

            activeCall = {
                id: callId,
                chatId: currentChat.id,
                userId: currentChat.otherUser.id,
                userName: getUserDisplayName(currentChat.otherUser),
                isIncoming: false,
                callType: selectedCallType,
                startTime: new Date(),
                messageId: callRef.id,
                stream: localStream
            };

            setupPeerConnection(configuration, true);

            showActiveCallScreen(activeCall);
            startCallTimer();

            await updateDoc(doc(db, 'chats', currentChat.id), {
                lastMessage: selectedCallType === 'video' ? '📹 Исходящий HD видеозвонок' : '📞 Исходящий HD звонок',
                updatedAt: serverTimestamp()
            });

            showLoading(false);
            showNotification('HD звонок начат', 'success');

        } catch (error) {
            console.error('Ошибка начала звонка:', error);
            showNotification('Ошибка: ' + error.message, 'error');
            showLoading(false);
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
        }
    }

    function setupPeerConnection(configuration, isInitiator) {
        if (peerConnection) {
            peerConnection.close();
        }
        
        if (!configuration || typeof configuration !== 'object') {
            configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };
        }
        
        peerConnection = new RTCPeerConnection(configuration);

        try {
            const codecPreferences = ['video/VP9', 'video/VP8', 'video/H264'];
            const rtpTransceivers = peerConnection.getTransceivers();
            rtpTransceivers.forEach(transceiver => {
                if (transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === 'video') {
                    const codecs = RTCRtpReceiver.getCapabilities('video').codecs;
                    const sortedCodecs = codecPreferences
                        .map(name => codecs.find(c => c.mimeType.includes(name)))
                        .filter(c => c);
                    
                    if (sortedCodecs.length > 0) {
                        transceiver.setCodecPreferences(sortedCodecs);
                        console.log('🎥 Приоритет кодека для качества:', sortedCodecs[0].mimeType);
                    }
                }
            });
        } catch (e) {
            console.warn('Не удалось установить приоритет кодека:', e);
        }

        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                console.log(`📹 Добавлен трек: ${track.kind}`);
            });
        }

        setTimeout(() => {
            const senders = peerConnection.getSenders();
            senders.forEach(sender => {
                if (sender.track && sender.track.kind === 'video') {
                    const params = sender.getParameters();
                    if (!params.encodings) params.encodings = [{}];
                    
                    params.encodings[0].maxBitrate = 2500000;
                    params.encodings[0].minBitrate = 500000;
                    params.encodings[0].scaleResolutionDownBy = 1;
                    
                    sender.setParameters(params).then(() => {
                        console.log('✅ Установлен высокий битрейт видео');
                    }).catch(e => console.warn('Не удалось установить битрейт:', e));
                }
                if (sender.track && sender.track.kind === 'audio') {
                    const params = sender.getParameters();
                    if (!params.encodings) params.encodings = [{}];
                    
                    params.encodings[0].maxBitrate = 128000;
                    
                    sender.setParameters(params).then(() => {
                        console.log('✅ Установлен высокий битрейт аудио');
                    }).catch(e => console.warn('Не удалось установить битрейт аудио:', e));
                }
            });
        }, 1000);

        peerConnection.onicecandidate = async (event) => {
            if (event.candidate && activeCall) {
                console.log('📞 Новый ICE кандидат:', event.candidate.candidate.split(' ')[7]);
                try {
                    await addDoc(collection(db, 'call_signals'), {
                        callId: activeCall.id,
                        candidate: event.candidate.toJSON(),
                        from: currentUser.id,
                        to: activeCall.userId,
                        timestamp: serverTimestamp()
                    });
                } catch (err) {
                    console.warn('Не удалось отправить ICE кандидата:', err);
                }
            }
        };

        peerConnection.ontrack = (event) => {
            const remoteVideo = document.getElementById('remoteVideo');
            if (remoteVideo) {
                remoteVideo.srcObject = event.streams[0];
                remoteStream = event.streams[0];
                console.log('📞 Удаленный поток получен');
                showNotification('Собеседник подключился', 'success');
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log('📞 Состояние соединения:', peerConnection.connectionState);
            const qualityEl = document.getElementById('connectionQuality');
            if (qualityEl) {
                if (peerConnection.connectionState === 'connected') {
                    qualityEl.innerHTML = '📶 HD качество (P2P)';
                    qualityEl.className = 'connection-quality good';
                } else if (peerConnection.connectionState === 'disconnected') {
                    qualityEl.innerHTML = '📶 Соединение прервано';
                    qualityEl.className = 'connection-quality poor';
                } else if (peerConnection.connectionState === 'failed') {
                    qualityEl.innerHTML = '📶 Ошибка соединения';
                    qualityEl.className = 'connection-quality poor';
                } else if (peerConnection.connectionState === 'connecting') {
                    qualityEl.innerHTML = '📶 Устанавливаем соединение...';
                    qualityEl.className = 'connection-quality fair';
                }
            }
        };

        peerConnection.oniceconnectionstatechange = () => {
            console.log('📞 ICE состояние:', peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') {
                console.log('🔄 ICE соединение не удалось, пробуем переподключиться...');
                peerConnection.restartIce();
            }
        };

        peerConnection.onsignalingstatechange = () => {
            console.log('📞 Сигнальное состояние:', peerConnection.signalingState);
        };

        peerConnection.onicegatheringstatechange = () => {
            console.log('📞 Сбор ICE кандидатов:', peerConnection.iceGatheringState);
        };

        if (isInitiator) {
            console.log('📞 Создаем оффер...');
            peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: selectedCallType === 'video',
                iceRestart: true
            })
                .then(offer => {
                    console.log('✅ Оффер создан');
                    return peerConnection.setLocalDescription(offer);
                })
                .then(() => {
                    console.log('📤 Отправляем оффер...');
                    return addDoc(collection(db, 'call_signals'), {
                        callId: activeCall.id,
                        offer: peerConnection.localDescription.toJSON(),
                        from: currentUser.id,
                        to: activeCall.userId,
                        timestamp: serverTimestamp()
                    });
                })
                .then(() => {
                    console.log('✅ Оффер отправлен');
                })
                .catch(error => {
                    console.error('❌ Ошибка создания оффера:', error);
                    showNotification('Ошибка создания звонка', 'error');
                });
        }

        listenForSignals();
        startConnectionQualityMonitor();
    }

    function startConnectionQualityMonitor() {
        if (!peerConnection) return;
        
        const interval = setInterval(async () => {
            if (!peerConnection || peerConnection.connectionState !== 'connected') {
                return;
            }
            await updateConnectionQuality();
        }, 2000);
        
        if (!window.qualityIntervals) window.qualityIntervals = [];
        window.qualityIntervals.push(interval);
    }

    async function listenForSignals() {
        if (!activeCall) return;

        if (callListeners.has('signals')) {
            callListeners.get('signals')();
            callListeners.delete('signals');
        }

        const signalsQuery = query(
            collection(db, 'call_signals'),
            where('callId', '==', activeCall.id),
            orderBy('timestamp', 'asc')
        );

        const unsubscribe = onSnapshot(signalsQuery, async (snapshot) => {
            snapshot.docChanges().forEach(async (change) => {
                if (change.type === 'added') {
                    const signal = change.doc.data();
                    
                    if (signal.from === currentUser.id) return;

                    try {
                        if (signal.offer && !peerConnection.currentRemoteDescription) {
                            console.log('📞 Получен оффер, создаем ответ...');
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.offer));
                            
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            
                            console.log('📤 Отправляем ответ...');
                            await addDoc(collection(db, 'call_signals'), {
                                callId: activeCall.id,
                                answer: peerConnection.localDescription.toJSON(),
                                from: currentUser.id,
                                to: signal.from,
                                timestamp: serverTimestamp()
                            });
                            console.log('✅ Ответ отправлен');
                        }
                        
                        else if (signal.answer && !peerConnection.currentRemoteDescription) {
                            console.log('📞 Получен ответ, устанавливаем соединение...');
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.answer));
                            console.log('✅ Соединение установлено!');
                        }
                        
                        else if (signal.candidate) {
                            console.log('📞 Получен ICE кандидат');
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                                console.log('✅ ICE кандидат добавлен');
                            } catch (e) {
                                console.error('Ошибка добавления ICE кандидата:', e);
                            }
                        }
                    } catch (error) {
                        console.error('❌ Ошибка обработки сигнала:', error);
                    }
                }
            });
        }, (error) => {
            console.error('❌ Ошибка слушателя сигналов:', error);
        });
        
        callListeners.set('signals', unsubscribe);
    }

    async function updateConnectionQuality() {
        if (!peerConnection) return;
        
        try {
            const stats = await peerConnection.getStats();
            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    const rtt = report.currentRoundTripTime;
                    const qualityEl = document.getElementById('connectionQuality');
                    
                    if (rtt < 0.1) {
                        qualityEl.className = 'connection-quality good';
                        qualityEl.innerHTML = '📶 HD качество (P2P)';
                    } else if (rtt < 0.3) {
                        qualityEl.className = 'connection-quality fair';
                        qualityEl.innerHTML = '📶 Среднее соединение';
                    } else {
                        qualityEl.className = 'connection-quality poor';
                        qualityEl.innerHTML = '📶 Плохое соединение';
                    }
                    
                    if (report.localCandidateId && report.remoteCandidateId) {
                        const localCandidate = stats.get(report.localCandidateId);
                        const remoteCandidate = stats.get(report.remoteCandidateId);
                        if (localCandidate && remoteCandidate) {
                            if (localCandidate.candidateType === 'relay' || remoteCandidate.candidateType === 'relay') {
                                qualityEl.innerHTML += ' (релей)';
                            } else if (localCandidate.candidateType === 'srflx' || remoteCandidate.candidateType === 'srflx') {
                                qualityEl.innerHTML += ' (NAT)';
                            } else {
                                qualityEl.innerHTML += ' (локально)';
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.warn('Ошибка получения статистики соединения:', error);
        }
    }

    async function answerCall(callData) {
        try {
            showLoading(true);

            const constraints = callData.callType === 'video' 
                ? { 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000,
                        channelCount: 2,
                        sampleSize: 16
                    }, 
                    video: {
                        width: { ideal: 1280, min: 640, max: 1920 },
                        height: { ideal: 720, min: 480, max: 1080 },
                        frameRate: { ideal: 30, min: 15, max: 60 },
                        aspectRatio: 1.7777777778
                    }
                  } 
                : { 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000,
                        channelCount: 2,
                        sampleSize: 16
                    }
                  };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(localStream);
            const gainNode = audioContext.createGain();
            const compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-50, audioContext.currentTime);
            compressor.knee.setValueAtTime(40, audioContext.currentTime);
            compressor.ratio.setValueAtTime(12, audioContext.currentTime);
            
            gainNode.gain.value = 1.2;
            
            source.connect(compressor);
            compressor.connect(gainNode);
            const destination = audioContext.createMediaStreamDestination();
            gainNode.connect(destination);
            
            const videoTracks = localStream.getVideoTracks();
            const enhancedStream = destination.stream;
            videoTracks.forEach(track => enhancedStream.addTrack(track));
            localStream = enhancedStream;
            
            if (callData.callType === 'video') {
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                document.getElementById('videoContainer').style.display = 'block';
                document.getElementById('audioCallContainer').style.display = 'none';
            } else {
                document.getElementById('videoContainer').style.display = 'none';
                document.getElementById('audioCallContainer').style.display = 'block';
            }

            currentCallId = callData.callId;

            await updateDoc(doc(db, 'messages', callData.id), {
                answered: true,
                answeredAt: serverTimestamp(),
                callActive: true
            });

            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    { urls: 'stun:stun.ekiga.net' },
                    { urls: 'stun:stun.ideasip.com' },
                    { urls: 'stun:stun.schlund.de' },
                    { urls: 'stun:stun.stunprotocol.org:3478' },
                    { urls: 'stun:stun.voiparound.com' },
                    { urls: 'stun:stun.voipbuster.com' },
                    { urls: 'stun:stun.voipstunt.com' },
                    { urls: 'stun:stun.voxgratia.org' },
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                iceTransportPolicy: 'all',
                iceCandidatePoolSize: 10,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };

            activeCall = {
                id: callData.callId,
                chatId: callData.chatId,
                userId: callData.senderId,
                userName: callData.senderName,
                isIncoming: true,
                callType: callData.callType,
                startTime: new Date(),
                messageId: callData.id,
                stream: localStream
            };

            setupPeerConnection(configuration, false);

            document.getElementById('callNotification').classList.add('hidden');
            stopRingtone();
            hideCallRingingIndicator();

            showActiveCallScreen(activeCall);
            startCallTimer();

            await updateDoc(doc(db, 'chats', callData.chatId), {
                lastMessage: callData.callType === 'video' ? '📹 Принятый HD видеозвонок' : '📞 Принятый HD звонок',
                updatedAt: serverTimestamp()
            });

            showLoading(false);
            showNotification('HD звонок принят', 'success');

        } catch (error) {
            console.error('Ошибка принятия звонка:', error);
            showNotification('Ошибка принятия звонка', 'error');
            showLoading(false);
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
        }
    }

    async function rejectCall(callData) {
        try {
            await updateDoc(doc(db, 'messages', callData.id), {
                callActive: false,
                rejected: true,
                rejectedAt: serverTimestamp()
            });

            await updateDoc(doc(db, 'chats', callData.chatId), {
                lastMessage: callData.callType === 'video' ? '📹 Отклоненный HD видеозвонок' : '📞 Отклоненный HD звонок',
                updatedAt: serverTimestamp()
            });

            document.getElementById('callNotification').classList.add('hidden');
            stopRingtone();
            hideCallRingingIndicator();
            incomingCallData = null;

        } catch (error) {
            console.error('Ошибка отклонения звонка:', error);
        }
    }

    async function endCall() {
        if (!activeCall) return;

        try {
            if (activeCall.id) {
                try {
                    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
                    const oldSignalsQuery = query(
                        collection(db, 'call_signals'),
                        where('callId', '==', activeCall.id),
                        where('timestamp', '<', oneHourAgo)
                    );
                    
                    const snapshot = await getDocs(oldSignalsQuery);
                    const deletePromises = [];
                    snapshot.forEach(doc => deletePromises.push(deleteDoc(doc.ref)));
                    await Promise.all(deletePromises);
                } catch (error) {
                    console.warn('Не удалось очистить старые сигналы:', error);
                }
            }

            if (speakingIndicatorInterval) {
                clearInterval(speakingIndicatorInterval);
                speakingIndicatorInterval = null;
            }

            if (window.qualityIntervals) {
                window.qualityIntervals.forEach(interval => clearInterval(interval));
                window.qualityIntervals = [];
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (activeCall.messageId) {
                try {
                    await updateDoc(doc(db, 'messages', activeCall.messageId), {
                        callActive: false,
                        endedAt: serverTimestamp(),
                        duration: Math.floor((Date.now() - activeCall.startTime.getTime()) / 1000)
                    });
                } catch (error) {
                    console.log('Звонок уже завершен или удален');
                }
            }

            if (activeCall.chatId) {
                try {
                    await updateDoc(doc(db, 'chats', activeCall.chatId), {
                        lastMessage: activeCall.callType === 'video' ? 
                            `📹 HD видеозвонок (${formatCallDuration(activeCall.startTime)})` :
                            `📞 HD звонок (${formatCallDuration(activeCall.startTime)})`,
                        updatedAt: serverTimestamp()
                    });
                } catch (error) {
                    console.warn('Не удалось обновить чат:', error);
                }
            }

            document.getElementById('callActiveScreen').classList.add('hidden');
            
            if (currentChat) {
                showScreen('chatScreen');
            } else {
                showScreen('chatsScreen');
            }

            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }

            activeCall = null;
            currentCallId = null;
            isMuted = false;
            isSpeakerOn = false;
            isVideoOn = true;

            if (callListeners.size > 0) {
                callListeners.forEach(unsubscribe => {
                    if (typeof unsubscribe === 'function') unsubscribe();
                });
                callListeners.clear();
            }

            loadChats();

            showNotification('HD звонок завершен', 'info');

        } catch (error) {
            console.error('Ошибка завершения звонка:', error);
            showNotification('Ошибка завершения звонка', 'error');
        }
    }

    async function checkCallStatus() {
        if (!activeCall || !activeCall.messageId) return;
        
        try {
            const callDoc = await getDoc(doc(db, 'messages', activeCall.messageId));
            if (callDoc.exists()) {
                const callData = callDoc.data();
                if (!callData.callActive) {
                    await endCall();
                    showNotification('Собеседник завершил звонок', 'info');
                }
            } else {
                await endCall();
                showNotification('Звонок был завершен', 'info');
            }
        } catch (error) {
            console.error('Ошибка проверки статуса звонка:', error);
        }
    }

    function showActiveCallScreen(call) {
        document.getElementById('callActiveName').textContent = call.userName;
        document.getElementById('callActiveStatus').textContent = call.isIncoming ? 
            'Входящий HD звонок' : 'Исходящий HD звонок';
        document.getElementById('callActiveTimer').textContent = '00:00';

        const avatar = document.getElementById('callActiveAvatar');
        avatar.style.background = getRandomColor();
        avatar.textContent = call.userName.charAt(0).toUpperCase();

        if (call.callType === 'video') {
            document.getElementById('videoContainer').style.display = 'block';
            document.getElementById('audioCallContainer').style.display = 'none';
            document.getElementById('callTypeIcon').textContent = '📹';
        } else {
            document.getElementById('videoContainer').style.display = 'none';
            document.getElementById('audioCallContainer').style.display = 'block';
            document.getElementById('callTypeIcon').textContent = '📞';
        }

        startSpeakingIndicator();

        document.getElementById('callActiveScreen').classList.remove('hidden');
        
        updateCallButtons();
        
        if (call.checkInterval) {
            clearInterval(call.checkInterval);
        }
        call.checkInterval = setInterval(checkCallStatus, 5000);
    }

    function startSpeakingIndicator() {
        if (speakingIndicatorInterval) {
            clearInterval(speakingIndicatorInterval);
        }
        
        speakingIndicatorInterval = setInterval(() => {
            const indicator = document.getElementById('speakingIndicator');
            const isSpeaking = Math.random() > 0.7;
            
            if (isSpeaking) {
                indicator.classList.add('speaking-active');
            } else {
                indicator.classList.remove('speaking-active');
            }
        }, 1000);
    }

    function updateCallButtons() {
        const callBtn = document.getElementById('callBtn');
        const videoCallBtn = document.getElementById('videoCallBtn');
        
        if (activeCall) {
            if (activeCall.callType === 'video') {
                videoCallBtn.classList.add('active-call');
                videoCallBtn.innerHTML = '📞';
                videoCallBtn.title = 'Завершить звонок';
                callBtn.style.display = 'none';
            } else {
                callBtn.classList.add('active-call');
                callBtn.innerHTML = '📞';
                callBtn.title = 'Завершить звонок';
                videoCallBtn.style.display = 'none';
            }
        } else {
            callBtn.classList.remove('active-call');
            videoCallBtn.classList.remove('active-call');
            callBtn.innerHTML = '📞';
            videoCallBtn.innerHTML = '📹';
            callBtn.title = 'HD Аудиозвонок';
            videoCallBtn.title = 'HD Видеозвонок';
            
            updateCallButtonsVisibility();
        }
    }

    function startCallTimer() {
        callStartTime = new Date();
        
        if (callTimer) {
            clearInterval(callTimer);
        }
        
        callTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - callStartTime.getTime()) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('callActiveTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            updateConnectionQuality();
        }, 1000);
    }

    function formatCallDuration(startTime) {
        const elapsed = Math.floor((Date.now() - startTime.getTime()) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function generateCallId() {
        return 'call_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // ==================== УВЕДОМЛЕНИЯ О ЗВОНКАХ ====================
    async function setupCallListeners() {
        if (!currentUser || authError) return;

        try {
            const callsQuery = query(
                collection(db, 'messages'),
                where('type', '==', 'call'),
                where('recipientId', '==', currentUser.id),
                where('callActive', '==', true)
            );

            const unsubscribe = onSnapshot(callsQuery, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && !activeCall) {
                        const callData = {
                            id: change.doc.id,
                            ...change.doc.data()
                        };

                        if (callData.senderId === currentUser.id) return;
                        if (callData.callActive !== true) return;
                        if (incomingCallData && incomingCallData.id === callData.id) return;

                        incomingCallData = callData;

                        if (currentChat && currentChat.id === callData.chatId) {
                            showCallRingingIndicator(callData);
                        } else {
                            showIncomingCallNotification(callData);
                        }
                    }
                });
            }, (error) => {
                console.warn('Ошибка слушателя звонков:', error);
            });

            callListeners.set('main', unsubscribe);
            return unsubscribe;
        } catch (error) {
            console.error('Ошибка настройки слушателя звонков:', error);
        }
    }

    function showIncomingCallNotification(callData) {
        const notificationElement = document.getElementById('callNotification');
        if (!notificationElement) return;
        
        document.getElementById('callerName').textContent = callData.senderName;
        
        if (callData.callType === 'video') {
            document.getElementById('callNotificationIcon').textContent = '📹 Входящий HD видеозвонок';
            document.getElementById('callTypeText').textContent = 'HD Видеозвонок';
            notificationElement.classList.add('video');
        } else {
            document.getElementById('callNotificationIcon').textContent = '📞 Входящий HD звонок';
            document.getElementById('callTypeText').textContent = 'HD Аудиозвонок';
            notificationElement.classList.remove('video');
        }
        
        notificationElement.classList.remove('hidden');
        
        playRingtone();
        
        setTimeout(() => {
            if (notificationElement && !notificationElement.classList.contains('hidden')) {
                notificationElement.classList.add('hidden');
                stopRingtone();
                if (incomingCallData) {
                    rejectCall(incomingCallData);
                }
            }
        }, 30000);
    }

    function playRingtone() {
        const ringtone = document.getElementById('ringtone');
        ringtone.volume = 0.3;
        ringtone.currentTime = 0;
        ringtone.play().catch(e => {
            console.log('Ошибка воспроизведения рингтона:', e);
            const callerName = document.getElementById('callerName')?.textContent || 'Неизвестный абонент';
            showPushNotification('Входящий HD звонок', callerName + ' звонит вам');
        });
    }

    function stopRingtone() {
        const ringtone = document.getElementById('ringtone');
        ringtone.pause();
        ringtone.currentTime = 0;
    }

    // ==================== ФУНКЦИИ ДЛЯ ЗАГРУЗКИ ФАЙЛОВ ====================
    function createUploadProgress(fileId, fileName, fileSize) {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'upload-progress-container';
        progressContainer.id = `upload-progress-${fileId}`;
        
        const progressBar = document.createElement('div');
        progressBar.className = 'upload-progress-bar';
        
        const progress = document.createElement('div');
        progress.className = 'upload-progress';
        progress.appendChild(progressBar);
        
        const progressText = document.createElement('div');
        progressText.className = 'upload-progress-text';
        progressText.textContent = `Загрузка: 0%`;
        
        progressContainer.appendChild(progress);
        progressContainer.appendChild(progressText);
        
        return {
            container: progressContainer,
            progressBar: progressBar,
            text: progressText
        };
    }

    async function uploadFileWithProgress(file, messageElementId = null) {
        const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const chunkSize = 1 * 1024 * 1024;
        const totalChunks = Math.ceil(file.size / chunkSize);
        let uploadedChunks = 0;
        
        let progressUI = null;
        if (messageElementId) {
            const messageElement = document.getElementById(messageElementId);
            if (messageElement) {
                progressUI = createUploadProgress(fileId, file.name, file.size);
                messageElement.appendChild(progressUI.container);
            }
        }
        
        if (file.size > 1 * 1024 * 1024) {
            showNotification(`Начинаем загрузку файла ${file.name} (${formatFileSize(file.size)})`, 'info');
            
            const chunks = [];
            for (let start = 0; start < file.size; start += chunkSize) {
                const chunk = file.slice(start, start + chunkSize);
                chunks.push(chunk);
            }
            
            const uploadedData = [];
            
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                const chunkReader = new FileReader();
                
                await new Promise((resolve, reject) => {
                    chunkReader.onload = async (event) => {
                        try {
                            uploadedData.push(event.target.result);
                            uploadedChunks++;
                            
                            const progressPercent = Math.floor((uploadedChunks / totalChunks) * 100);
                            if (progressUI) {
                                progressUI.progressBar.style.width = `${progressPercent}%`;
                                progressUI.text.textContent = `Загрузка: ${progressPercent}%`;
                            }
                            
                            setTimeout(resolve, 100);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    chunkReader.onerror = reject;
                    chunkReader.readAsDataURL(chunk);
                });
            }
            
            const completeFile = new Blob(chunks, { type: file.type });
            return await readFileAsBase64(completeFile);
        } else {
            return await readFileAsBase64(file);
        }
    }

    // ==================== НОВЫЕ ФУНКЦИИ ====================
    function showEditMessageModal(messageId, currentText) {
        currentlyEditingMessage = messageId;
        const newText = prompt('Редактировать сообщение:', currentText);
        if (newText && newText.trim() !== '') {
            editMessage(messageId, newText.trim());
        }
    }

    async function editMessage(messageId, newText) {
        if (!currentUser || !currentChat) return;
        
        try {
            if (authError) {
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                const index = messages.findIndex(m => m.id === messageId);
                if (index !== -1) {
                    messages[index].text = newText;
                    messages[index].edited = true;
                    messages[index].editedAt = new Date().toISOString();
                    localStorage.setItem('absgram_messages', JSON.stringify(messages));
                    loadMessages(currentChat.id);
                    showNotification('Сообщение отредактировано', 'success');
                }
                return;
            }
            
            const messageRef = doc(db, 'messages', messageId);
            await updateDoc(messageRef, {
                text: newText,
                edited: true,
                editedAt: serverTimestamp()
            });
            
            showNotification('Сообщение отредактировано', 'success');
        } catch (error) {
            console.error('Ошибка редактирования:', error);
            showNotification('Ошибка редактирования', 'error');
        }
        currentlyEditingMessage = null;
    }

    async function addReaction(messageId, reaction) {
        if (!currentUser) return;
        
        try {
            if (authError) {
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                const index = messages.findIndex(m => m.id === messageId);
                if (index !== -1) {
                    if (!messages[index].reactions) messages[index].reactions = {};
                    if (!messages[index].reactions[reaction]) messages[index].reactions[reaction] = [];
                    
                    const userIndex = messages[index].reactions[reaction].indexOf(currentUser.id);
                    if (userIndex === -1) {
                        messages[index].reactions[reaction].push(currentUser.id);
                    } else {
                        messages[index].reactions[reaction].splice(userIndex, 1);
                        if (messages[index].reactions[reaction].length === 0) {
                            delete messages[index].reactions[reaction];
                        }
                    }
                    
                    localStorage.setItem('absgram_messages', JSON.stringify(messages));
                    loadMessages(currentChat.id);
                }
                return;
            }
            
            const messageRef = doc(db, 'messages', messageId);
            const messageDoc = await getDoc(messageRef);
            
            if (messageDoc.exists()) {
                const reactions = messageDoc.data().reactions || {};
                
                if (!reactions[reaction]) reactions[reaction] = [];
                
                const userIndex = reactions[reaction].indexOf(currentUser.id);
                if (userIndex === -1) {
                    reactions[reaction].push(currentUser.id);
                } else {
                    reactions[reaction].splice(userIndex, 1);
                    if (reactions[reaction].length === 0) {
                        delete reactions[reaction];
                    }
                }
                
                await updateDoc(messageRef, { reactions });
            }
        } catch (error) {
            console.error('Ошибка добавления реакции:', error);
        }
    }

    // ==================== ФУНКЦИИ ДЛЯ НЕПРОЧИТАННЫХ СООБЩЕНИЙ ====================
    function updateUnreadCounts() {
        if (!currentUser) return;
        
        if (authError) {
            const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
            const unreadMap = new Map();
            
            messages.forEach(msg => {
                if (msg.senderId !== currentUser.id && !msg.read && msg.chatId) {
                    unreadMap.set(msg.chatId, (unreadMap.get(msg.chatId) || 0) + 1);
                }
            });
            
            unreadCounts = unreadMap;
            updateChatListUnreadBadges();
            return;
        }
        
        try {
            const messagesQuery = query(
                collection(db, 'messages'),
                where('read', '==', false)
            );
            
            onSnapshot(messagesQuery, (snapshot) => {
                const unreadMap = new Map();
                
                snapshot.forEach(doc => {
                    const message = doc.data();
                    if (message.senderId !== currentUser.id && message.chatId) {
                        unreadMap.set(message.chatId, (unreadMap.get(message.chatId) || 0) + 1);
                    }
                });
                
                unreadCounts = unreadMap;
                updateChatListUnreadBadges();
            });
        } catch (error) {
            console.error('Ошибка обновления непрочитанных сообщений:', error);
        }
    }

    function updateChatListUnreadBadges() {
        const chatItems = document.querySelectorAll('.chat-item');
        
        chatItems.forEach(item => {
            if (item.dataset.chatId) {
                const chatId = item.dataset.chatId;
                const unreadCount = unreadCounts.get(chatId) || 0;
                
                const oldBadge = item.querySelector('.chat-unread-badge');
                if (oldBadge) {
                    oldBadge.remove();
                }
                
                if (unreadCount > 0) {
                    const badge = document.createElement('div');
                    badge.className = 'chat-unread-badge';
                    badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                    const infoDiv = item.querySelector('.chat-info');
                    if (infoDiv) {
                        infoDiv.appendChild(badge);
                    }
                }
            }
        });
    }

    async function markMessagesAsRead(chatId) {
        if (!currentUser) return;
        
        try {
            if (authError) {
                const messages = JSON.parse(localStorage.getItem('absgram_messages') || '[]');
                let updated = false;
                
                const updatedMessages = messages.map(msg => {
                    if (msg.chatId === chatId && msg.senderId !== currentUser.id && !msg.read) {
                        msg.read = true;
                        updated = true;
                    }
                    return msg;
                });
                
                if (updated) {
                    localStorage.setItem('absgram_messages', JSON.stringify(updatedMessages));
                    unreadCounts.delete(chatId);
                    updateChatListUnreadBadges();
                }
                return;
            }
            
            const messagesQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', chatId),
                where('senderId', '!=', currentUser.id),
                where('read', '==', false)
            );
            
            const snapshot = await getDocs(messagesQuery);
            const updatePromises = [];
            
            snapshot.forEach(doc => {
                updatePromises.push(updateDoc(doc.ref, { read: true }));
            });
            
            await Promise.all(updatePromises);
            
            unreadCounts.delete(chatId);
            updateChatListUnreadBadges();
            
        } catch (error) {
            console.error('Ошибка пометки сообщений как прочитанных:', error);
        }
    }

    // ==================== ФУНКЦИИ ДЛЯ КАНАЛОВ ====================
    async function createChannel() {
        const channelName = document.getElementById('channelName').value.trim();
        const channelDesc = document.getElementById('channelDescription').value.trim();
        const channelType = document.getElementById('channelType').value;
        
        if (!channelName) {
            showNotification('Введите название канала', 'error');
            return;
        }
        
        showLoading(true);
        try {
            if (authError) {
                const channelId = 'channel_' + Date.now();
                const channelData = {
                    id: channelId,
                    name: channelName,
                    description: channelDesc || '',
                    type: channelType,
                    ownerId: currentUser.id,
                    subscribers: [currentUser.id],
                    subscriberCount: 1,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    isChannel: true
                };
                
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const chat = {
                    id: channelId,
                    participants: [currentUser.id],
                    isChannel: true,
                    channelName: channelName,
                    channelDesc: channelDesc,
                    channelOwner: currentUser.id,
                    channelType: channelType,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    lastMessage: 'Канал создан',
                    subscriberCount: 1
                };
                chats.push(chat);
                localStorage.setItem('absgram_chats', JSON.stringify(chats));
                
                closeGroupModal();
                loadChats();
                showLoading(false);
                return;
            }
            
            const chatData = {
                participants: [currentUser.id],
                isChannel: true,
                channelName: channelName,
                channelDesc: channelDesc,
                channelOwner: currentUser.id,
                channelType: channelType,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                lastMessage: 'Канал создан',
                subscriberCount: 1
            };
            
            const chatRef = await addDoc(collection(db, 'chats'), chatData);
            channels.set(chatRef.id, { id: chatRef.id, ...chatData });
            userSubscriptions.add(chatRef.id);
            
            showNotification('Канал создан!', 'success');
            closeGroupModal();
            loadChats();
            
        } catch (error) {
            console.error('Ошибка создания канала:', error);
            showNotification('Ошибка создания канала', 'error');
        } finally {
            showLoading(false);
        }
    }

    async function subscribeToChannel(channelId) {
        if (!currentUser) return;
        
        try {
            if (authError) {
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const chat = chats.find(c => c.id === channelId);
                if (chat) {
                    chat.participants.push(currentUser.id);
                    chat.subscriberCount = chat.participants.length;
                    localStorage.setItem('absgram_chats', JSON.stringify(chats));
                }
                
                userSubscriptions.add(channelId);
                showNotification('Вы подписались на канал', 'success');
                return;
            }
            
            const chatRef = doc(db, 'chats', channelId);
            const chatDoc = await getDoc(chatRef);
            if (!chatDoc.exists()) {
                throw new Error('Канал не найден');
            }
            
            await updateDoc(chatRef, {
                participants: arrayUnion(currentUser.id),
                subscriberCount: increment(1),
                updatedAt: serverTimestamp()
            });
            
            userSubscriptions.add(channelId);
            showNotification('Вы подписались на канал', 'success');
            loadChats();
            
        } catch (error) {
            console.error('Ошибка подписки на канал:', error);
            showNotification('Ошибка подписки', 'error');
        }
    }

    async function unsubscribeFromChannel(channelId) {
        if (!currentUser) return;
        
        try {
            if (authError) {
                const chats = JSON.parse(localStorage.getItem('absgram_chats') || '[]');
                const chatIndex = chats.findIndex(c => c.id === channelId);
                if (chatIndex !== -1) {
                    chats[chatIndex].participants = chats[chatIndex].participants.filter(id => id !== currentUser.id);
                    chats[chatIndex].subscriberCount = chats[chatIndex].participants.length;
                    localStorage.setItem('absgram_chats', JSON.stringify(chats));
                }
                
                userSubscriptions.delete(channelId);
                showNotification('Вы отписались от канала', 'info');
                return;
            }
            
            const chatRef = doc(db, 'chats', channelId);
            await updateDoc(chatRef, {
                participants: arrayRemove(currentUser.id),
                subscriberCount: increment(-1),
                updatedAt: serverTimestamp()
            });
            
            userSubscriptions.delete(channelId);
            showNotification('Вы отписались от канала', 'info');
            loadChats();
            
        } catch (error) {
            console.error('Ошибка отписки от канала:', error);
            showNotification('Ошибка отписки', 'error');
        }
    }

    // ==================== ФУНКЦИИ ДЛЯ ПОИСКА СООБЩЕНИЙ ====================
    function searchMessages(query) {
        if (!query.trim()) {
            currentMessageSearch = { index: 0, results: [] };
            document.getElementById('searchMessagesCount').textContent = '';
            return;
        }

        const container = document.getElementById('messagesContainer');
        const messages = Array.from(container.children).filter(el => 
            el.classList.contains('message') && !el.classList.contains('call-message')
        );

        const results = [];
        const queryLower = query.toLowerCase();

        messages.forEach((msg, idx) => {
            const textEl = msg.querySelector('div:first-child');
            if (textEl && textEl.textContent.toLowerCase().includes(queryLower)) {
                results.push(idx);
                const originalText = textEl.textContent;
                const regex = new RegExp(`(${query})`, 'gi');
                textEl.innerHTML = originalText.replace(regex, '<mark style="background: var(--primary); color: white; padding: 2px 4px; border-radius: 3px;">$1</mark>');
            } else {
                const originalText = textEl?.textContent;
                if (textEl && originalText) {
                    textEl.innerHTML = originalText;
                }
            }
        });

        currentMessageSearch = { index: 0, results };
        if (results.length > 0) {
            highlightSearchResult(results[0]);
        }
        document.getElementById('searchMessagesCount').textContent = results.length > 0 
            ? `${currentMessageSearch.index + 1}/${results.length}` 
            : '0';
    }

    function highlightSearchResult(index) {
        const container = document.getElementById('messagesContainer');
        const messages = Array.from(container.children).filter(el => el.classList.contains('message'));
        messages.forEach(msg => msg.classList.remove('search-highlight'));
        if (messages[index]) {
            messages[index].classList.add('search-highlight');
            messages[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    function nextSearchResult() {
        if (currentMessageSearch.results.length === 0) return;
        currentMessageSearch.index = (currentMessageSearch.index + 1) % currentMessageSearch.results.length;
        highlightSearchResult(currentMessageSearch.results[currentMessageSearch.index]);
        document.getElementById('searchMessagesCount').textContent = 
            `${currentMessageSearch.index + 1}/${currentMessageSearch.results.length}`;
    }

    function prevSearchResult() {
        if (currentMessageSearch.results.length === 0) return;
        currentMessageSearch.index = (currentMessageSearch.index - 1 + currentMessageSearch.results.length) % currentMessageSearch.results.length;
        highlightSearchResult(currentMessageSearch.results[currentMessageSearch.index]);
        document.getElementById('searchMessagesCount').textContent = 
            `${currentMessageSearch.index + 1}/${currentMessageSearch.results.length}`;
    }

    // ==================== ФУНКЦИИ ДЛЯ ИНДИКАТОРОВ НАБОРА ТЕКСТА ====================
    function setupTypingListener(chatId) {
        if (!chatId || typingListeners.has(chatId) || authError) return;
        
        try {
            const typingRef = collection(db, 'typing');
            const q = query(typingRef, where('chatId', '==', chatId));
            
            const unsubscribe = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    if (data.userId !== currentUser.id) {
                        if (change.type === 'added' || change.type === 'modified') {
                            showTypingIndicator(data.userId, data.isTyping);
                        } else if (change.type === 'removed') {
                            hideTypingIndicator(data.userId);
                        }
                    }
                });
            }, (error) => {
                console.warn('Ошибка слушателя набора текста:', error);
            });
            
            typingListeners.set(chatId, unsubscribe);
        } catch (error) {
            console.error('Ошибка настройки слушателя набора текста:', error);
        }
    }

    function showTypingIndicator(userId, isTyping) {
        if (!currentChat || currentChat.isGroup || currentChat.isChannel) return;
        
        const typingEl = document.getElementById('typingStatus');
        if (isTyping) {
            const userName = getUserDisplayName({ id: userId, name: 'Пользователь' });
            typingEl.querySelector('span').textContent = `${userName} печатает`;
            typingEl.classList.remove('hidden');
        } else {
            typingEl.classList.add('hidden');
        }
    }

    function hideTypingIndicator(userId) {
        const typingEl = document.getElementById('typingStatus');
        typingEl.classList.add('hidden');
    }

    async function updateTypingStatus(isTyping) {
        if (!currentChat || !currentUser || authError) return;
        
        if (typingTimeouts.has(currentChat.id)) {
            clearTimeout(typingTimeouts.get(currentChat.id));
        }
        
        try {
            const typingRef = collection(db, 'typing');
            const q = query(
                typingRef,
                where('chatId', '==', currentChat.id),
                where('userId', '==', currentUser.id)
            );
            
            const snapshot = await getDocs(q);
            
            if (isTyping) {
                if (snapshot.empty) {
                    await addDoc(typingRef, {
                        chatId: currentChat.id,
                        userId: currentUser.id,
                        isTyping: true,
                        timestamp: serverTimestamp()
                    });
                } else {
                    snapshot.forEach(async (doc) => {
                        await updateDoc(doc.ref, {
                            isTyping: true,
                            timestamp: serverTimestamp()
                        });
                    });
                }
                
                const timeout = setTimeout(() => {
                    updateTypingStatus(false);
                }, 3000);
                typingTimeouts.set(currentChat.id, timeout);
                
            } else {
                snapshot.forEach(async (doc) => {
                    await deleteDoc(doc.ref);
                });
            }
        } catch (error) {
            console.warn('Ошибка обновления статуса набора:', error);
        }
    }

    // ==================== ФУНКЦИИ ДЛЯ ИНДИКАТОРОВ ЗВОНКОВ ====================
    function setupCallRingingListener(chatId) {
        if (!chatId || callRingingListeners.has(chatId) || authError) return;
        
        try {
            const callsQuery = query(
                collection(db, 'messages'),
                where('chatId', '==', chatId),
                where('type', '==', 'call'),
                where('callActive', '==', true)
            );
            
            const unsubscribe = onSnapshot(callsQuery, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const callData = change.doc.data();
                        if (callData.senderId !== currentUser.id && !activeCall) {
                            showCallRingingIndicator(callData);
                        }
                    } else if (change.type === 'removed' || change.type === 'modified') {
                        hideCallRingingIndicator();
                    }
                });
            }, (error) => {
                console.warn('Ошибка слушателя звонков:', error);
            });
            
            callRingingListeners.set(chatId, unsubscribe);
        } catch (error) {
            console.error('Ошибка настройки слушателя звонков:', error);
        }
    }

    function showCallRingingIndicator(callData) {
        const ringingEl = document.getElementById('callRingingStatus');
        ringingEl.classList.remove('hidden');
    }

    function hideCallRingingIndicator() {
        const ringingEl = document.getElementById('callRingingStatus');
        ringingEl.classList.add('hidden');
    }

    // ==================== ФУНКЦИИ ДЛЯ ИСТОРИИ (ПОСТЫ) ====================
    function createPost() {
        const postText = prompt('Введите текст поста (до 200 символов):');
        if (!postText || postText.trim() === '') return;
        
        const post = {
            id: 'post_' + Date.now(),
            text: postText.trim(),
            createdAt: new Date().toISOString(),
            userId: currentUser.id
        };
        
        const userPosts = posts.get(currentUser.id) || [];
        userPosts.unshift(post);
        if (userPosts.length > 10) userPosts.pop();
        posts.set(currentUser.id, userPosts);
        
        updateProfile();
        showNotification('Пост добавлен в историю', 'success');
    }

    // ==================== ФУНКЦИИ ДЛЯ КАСТОМНЫХ РЕАКЦИЙ ====================
    let currentReactionMessageId = null;

    function showCustomReactionModal(messageId) {
        currentReactionMessageId = messageId;
        document.getElementById('customReactionModal').classList.remove('hidden');
    }

    document.getElementById('customReactionInput').addEventListener('input', function(e) {});

    document.getElementById('applyCustomReactionBtn').addEventListener('click', () => {
        const customReaction = document.getElementById('customReactionInput').value.trim();
        if (customReaction && currentReactionMessageId) {
            addReaction(currentReactionMessageId, customReaction);
        }
        document.getElementById('customReactionModal').classList.add('hidden');
        document.getElementById('customReactionInput').value = '';
    });

    document.getElementById('cancelCustomReactionBtn').addEventListener('click', () => {
        document.getElementById('customReactionModal').classList.add('hidden');
        document.getElementById('customReactionInput').value = '';
    });

    document.querySelectorAll('.custom-reaction-item').forEach(item => {
        item.addEventListener('click', function() {
            const emoji = this.textContent;
            document.getElementById('customReactionInput').value = emoji;
        });
    });

    // ==================== ИНИЦИАЛИЗАЦИЯ ====================
    function init() {
        console.log("🚀 Инициализация AbSgram 7.5 HD...");
        initEventListeners();
        
        if (authError) {
            console.log("⚠️ Работаем в локальном режиме (офлайн)");
            const savedUser = localStorage.getItem('absgram_user_local');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                showScreen('chatsScreen');
                loadChats();
                loadAllNicknames();
                updateUnreadCounts();
                loadCallsDisabledState();
            } else {
                showScreen('authScreen');
            }
            return;
        }
        
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log("👤 Пользователь аутентифицирован:", user.uid);
                await loadUserData(user.uid);
                
                if (currentUser) {
                    console.log("✅ Пользователь загружен успешно");
                    showScreen('chatsScreen');
                    await loadAllUsersForSearch();
                    await loadChats();
                    loadAllNicknames();
                    setupOnlineStatusListener();
                    requestNotificationPermission();
                    setupCallListeners();
                    updateUnreadCounts();
                    loadCallsDisabledState();
                }
            } else {
                console.log("🔒 Пользователь не аутентифицирован");
                
                const savedUser = localStorage.getItem('absgram_user');
                if (savedUser) {
                    const userData = JSON.parse(savedUser);
                    const now = Date.now();
                    const savedTime = userData.timestamp;
                    
                    if (now - savedTime < 24 * 60 * 60 * 1000) {
                        console.log("📱 Используем локально сохраненного пользователя");
                        authError = true;
                        
                        const localUser = localStorage.getItem('absgram_user_local');
                        if (localUser) {
                            currentUser = JSON.parse(localUser);
                            showScreen('chatsScreen');
                            await loadChats();
                            loadAllNicknames();
                            updateUnreadCounts();
                            loadCallsDisabledState();
                        } else {
                            showScreen('authScreen');
                        }
                    } else {
                        showScreen('authScreen');
                    }
                } else {
                    showScreen('authScreen');
                }
            }
        });
        
        console.log("✅ Инициализация завершена");
    }

    window.removeFromGroup = function(userId) {
        groupMembers.delete(userId);
        updateGroupMembersList();
    };
    
    window.playVoiceMessage = playVoiceMessage;
    window.downloadVoiceMessage = downloadVoiceMessage;
    window.downloadFileFromMessage = downloadFileFromMessage;
    window.previewImage = previewImage;
    window.previewVideo = previewVideo;
    window.playVideoMessage = playVideoMessage;
    window.downloadLargeFile = downloadLargeFile;
    window.downloadLargeVideo = downloadLargeVideo;
    window.showEditMessageModal = showEditMessageModal;
    window.addReaction = addReaction;
    window.setReply = setReply;
    window.deleteMessage = deleteMessage;
    window.showCustomReactionModal = showCustomReactionModal;
    window.saveFileToDevice = saveFileToDevice;

    init();
    </script>
</body>
</html>
